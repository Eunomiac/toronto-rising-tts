--[[
    Game State Management Module (core/state.ttslua)

    Handles persistent game data storage, retrieval, and state transitions.
    Pattern based on Kings Dilemma state module with nested state access support.

    This module provides:
    - Nested state access (get/set values at any depth)
    - State initialization with default merging
    - State validation and sanitization
    - Phase management helpers

    The global 'gameState' table is defined in global.ttslua and accessed here.
]]

local S = {}
local U = require("lib.util")
local C = require("lib.constants")

-- ============================================================================
-- INTERNAL HELPER FUNCTIONS (Nested State Access)
-- ============================================================================

--- Safely navigates through nested tables using variable arguments
-- @param tableData table The root table to navigate
-- @param ... string|number Variable number of keys to navigate through
-- @return any The value at the end of the path, or nil if path doesn't exist
-- @usage getFromTable(gameState, "playerData", playerID, "hunger") -- Returns hunger value for player
local function getFromTable(tableData, ...)
    local keys = {...}

    while #keys > 0 do
        U.Val("getFromTable()", tableData, tableData and U.Type(tableData) == "table",
            "Cannot navigate past non-table.")
        local thisKey = U.shift(keys)
        tableData = tableData[thisKey]
        if tableData == nil then return nil end
    end

    return tableData
end

--- Safely sets a value in a nested table, creating intermediate tables as needed
-- @param value any The value to set
-- @param tableData table The root table to modify
-- @param ... string|number Variable number of keys (last key is where value is set)
-- @return table The modified table (same reference as tableData)
-- @usage setInTable(3, gameState, "playerData", playerID, "hunger") -- Sets player's hunger to 3
local function setInTable(value, tableData, ...)
    -- Validate input
    if tableData == nil then
        error("setInTable() called with nil tableData")
    end
    if U.Type(tableData) ~= "table" then
        error("setInTable() called with non-table data: " .. U.ToString(tableData))
    end

    local keys = {...}
    if #keys == 0 then
        error("setInTable() called with no keys")
    end

    local finalKey = U.pop(keys)
    local tableRef = tableData
    local subTableKey, subTableData, subTableRef

    -- Navigate to the parent of the target key, creating intermediate tables if needed
    while #keys > 0 do
        local thisKey = U.shift(keys)

        -- Validate that current tableRef is a table
        if U.Type(tableRef) ~= "table" then
            error("setInTable() cannot navigate past non-table value at key: " .. U.ToString(thisKey))
        end

        if tableRef[thisKey] == nil then
            -- Need to create a new subtable path
            subTableKey = thisKey
            subTableData = {}
            subTableRef = subTableData
            break
        else
            -- Navigate deeper, but validate the value is a table
            local nextRef = tableRef[thisKey]
            if U.Type(nextRef) ~= "table" then
                -- Overwrite non-table value with a new table
                subTableKey = thisKey
                subTableData = {}
                subTableRef = subTableData
                break
            end
            tableRef = nextRef
        end
    end

    -- Create any remaining intermediate tables
    while #keys > 0 do
        local thisKey = U.shift(keys)
        if subTableRef == nil then
            subTableKey = thisKey
            subTableData = {}
            subTableRef = subTableData
        else
            subTableRef[thisKey] = {}
            subTableRef = subTableRef[thisKey]
        end
    end

    -- Validate tableRef is still a table before setting final value
    if U.Type(tableRef) ~= "table" then
        error("setInTable() final tableRef is not a table")
    end

    -- Set the final value, attaching newly created subtables if needed
    if subTableKey ~= nil then
        if subTableRef == nil then
            error("setInTable() subTableRef is nil but subTableKey is set")
        end
        subTableRef[finalKey] = value
        tableRef[subTableKey] = subTableData
    else
        tableRef[finalKey] = value
    end

    return tableData
end

-- ============================================================================
-- DEFAULT STATE DEFINITION
-- ============================================================================



--- Returns the default game state structure
-- This defines the initial state for a new game. Only dynamic values are stored here.
-- Static player data comes from C.PlayerData and is merged on load.
-- @return table Default game state structure
function S.GetDefaultGameState()
    -- Create playerData as a dictionary keyed by player ID (from C.PlayerIDs)
    -- Only dynamic values are stored here (values that change during gameplay)
    -- Static character data is in C.PlayerData and merged on load
    local playerData = {}
    for playerKey, playerID in pairs(C.PlayerIDs) do
        playerData[playerID] = {
            hunger = 0, -- Only dynamic values are stored in state
            -- Add other dynamic values here as needed (willpower current, health current, etc.)
        }
    end

    return {
        currentPhase = C.Phases.SESSION_START,
        playerData = playerData, -- Keyed by player ID, only dynamic values
        lights = {}, -- Light states will be stored here
        zones = {},  -- Zone-related data
        scene = {
            name = "",
            description = "",
            mood = "",
        },
        -- Add other top-level game state defaults
    }
end

--- Merges default values into a target table recursively
-- Ensures that new state keys are present in old saves (backward compatibility).
-- @param target table The target table to merge into (modified in place)
-- @param defaults table The default structure to merge from
function S.mergeDefaults(target, defaults)
    for k, v in pairs(defaults) do
        if target[k] == nil then
            target[k] = U.clone(v) -- Clone to avoid reference issues
        elseif type(v) == "table" and type(target[k]) == "table" then
            S.mergeDefaults(target[k], v) -- Recursively merge nested tables
        end
    end
end

--- Merges C.PlayerData on top of gameState.playerData with conflict detection
-- Static character data (from constants) is merged on top of dynamic state data.
-- Throws an error if there are conflicts (indicating dynamic data was incorrectly saved).
-- @param statePlayerData table The playerData from gameState (dynamic values only)
-- @return table Complete player data with static and dynamic merged
function S.mergePlayerData(statePlayerData)
    local merged = {}

    -- For each player ID in C.PlayerData
    for playerID, staticData in pairs(C.PlayerData) do
        -- Start with the static data (from constants)
        merged[playerID] = U.clone(staticData)

        -- Overlay dynamic data from state (if it exists)
        local dynamicData = statePlayerData and statePlayerData[playerID]
        if dynamicData then
            -- Check for conflicts (keys that exist in both but have different values)
            for key, dynamicValue in pairs(dynamicData) do
                if staticData[key] ~= nil then
                    -- This is a conflict - dynamic data shouldn't override static data
                    error(string.format(
                        "CONFLICT: Player ID '%s' has key '%s' in both C.PlayerData (static: %s) and gameState.playerData (dynamic: %s). " ..
                        "Dynamic values should only contain gameplay-state values, not character data.",
                        tostring(playerID), tostring(key), tostring(staticData[key]), tostring(dynamicValue)
                    ))
                end
                -- Safe to add - this is a dynamic value that doesn't exist in static data
                merged[playerID][key] = dynamicValue
            end
        end
    end

    return merged
end

-- ============================================================================
-- STATE INITIALIZATION & RESET
-- ============================================================================

--- Initializes game state from saved data or creates defaults
-- Merges loaded state with defaults to ensure all keys exist (backward compatibility).
-- Merges C.PlayerData (static) on top of gameState.playerData (dynamic).
-- @param saved_data string|table|nil JSON string containing saved state, table of saved state, or nil/empty for new game
-- @usage S.InitializeGameState(saved_data) -- Called in global.ttslua onLoad
function S.InitializeGameState(saved_data)
    if saved_data and saved_data ~= "" then
        -- Decode JSON string if needed
        if U.Type(saved_data) == "string" then
            saved_data = JSON.decode(saved_data)
        end

        print("State: Loading saved game state.")

        -- Start with defaults, then merge saved data (saved data takes precedence)
        gameState = U.clone(S.GetDefaultGameState())
        S.mergeDefaults(gameState, saved_data or {})

        -- Apply saved data on top of defaults (overwrites defaults)
        for k, v in pairs(saved_data or {}) do
            if k ~= "playerData" then
                gameState[k] = v
            else
                -- Special handling for playerData: merge with defaults first
                gameState.playerData = gameState.playerData or {}
                S.mergeDefaults(gameState.playerData, v or {})
            end
        end
    else
        print("State: Initializing new game state.")
        gameState = S.GetDefaultGameState()
    end

    -- Merge C.PlayerData (static) on top of gameState.playerData (dynamic)
    -- This creates the complete player data structure used at runtime
    -- gameState.playerData at this point contains only dynamic values (from save or defaults)
    print("State: Merging static player data from constants...")
    local completePlayerData = S.mergePlayerData(gameState.playerData)
    gameState.playerData = completePlayerData

    -- Ensure all required fields exist (validation/sanitization)
    S.validateState()

    print("State: Current phase is " .. S.getStateVal("currentPhase"))
end

--- Resets game state to defaults
-- @usage S.resetGameState() -- Start a new game
function S.resetGameState()
    print("State: Resetting game state to defaults.")
    gameState = S.GetDefaultGameState()
    S.validateState()
end

--- Validates and sanitizes game state
-- Ensures all required fields exist and have valid values.
-- Called automatically after initialization and reset.
function S.validateState()
    -- Ensure currentPhase exists and is valid
    if not gameState.currentPhase or not U.isIn(gameState.currentPhase, C.Phases) then
        gameState.currentPhase = C.Phases.SESSION_START
    end

    -- Ensure playerData table exists and has correct structure
    if not gameState.playerData then
        gameState.playerData = {}
    end

    -- Ensure other required top-level tables exist
    if not gameState.lights then gameState.lights = {} end
    if not gameState.zones then gameState.zones = {} end
    if not gameState.scene then gameState.scene = {} end
end

-- ============================================================================
-- STATE ACCESS (Basic Get/Set)
-- ============================================================================

--- Builds a save-safe state by explicitly copying only serializable fields
-- This is a whitelist approach - only includes fields we explicitly want to save
-- Much safer than trying to filter out non-serializable data
-- @return table A new table containing only serializable state data
local function buildSaveState()
    local saveState = {}

    -- Copy only the fields we want to save (whitelist approach)
    if gameState.currentPhase then
        saveState.currentPhase = gameState.currentPhase
    end

    if gameState.currentScene then
        saveState.currentScene = gameState.currentScene
    end

    -- Copy playerData (only dynamic values - static data comes from C.PlayerData)
    -- Extract only the dynamic gameplay-state values for each player ID
    -- Static character data should NOT be saved to state (it's in C.PlayerData constants)
    if gameState.playerData then
        saveState.playerData = {}
        for playerID, playerData in pairs(gameState.playerData) do
            -- Skip non-table entries (safety check)
            if type(playerData) ~= "table" then
                print("[WARNING] buildSaveState: Skipping player ID '" .. tostring(playerID) .. "' - not a table, type: " .. type(playerData))
                -- Skip this iteration
            -- Skip if the key itself is not serializable (should be a player ID string)
            elseif type(playerID) ~= "string" and type(playerID) ~= "number" then
                print("[WARNING] buildSaveState: Skipping player entry with non-serializable key type: " .. type(playerID))
                -- Skip this iteration
            else
                -- Extract only dynamic values from the complete merged playerData
                -- Static character data comes from C.PlayerData and should NOT be saved
                -- List of dynamic fields that should be saved (add more as needed)
                local dynamicFields = {"hunger"}  -- Currently only hunger is dynamic
                local dynamicPlayerData = {}

                for _, fieldName in ipairs(dynamicFields) do
                    local fieldSuccess, fieldVal = pcall(function() return playerData[fieldName] end)
                    if fieldSuccess and fieldVal ~= nil then
                        local fieldType = type(fieldVal)
                        if fieldType == "number" then
                            dynamicPlayerData[fieldName] = fieldVal
                        elseif fieldType == "string" then
                            -- Try to convert string numbers to actual numbers
                            local num = tonumber(fieldVal)
                            if num then
                                dynamicPlayerData[fieldName] = num
                            else
                                print("[WARNING] buildSaveState: Player ID '" .. tostring(playerID) .. "' " .. fieldName .. " is non-numeric string: " .. tostring(fieldVal))
                            end
                        elseif fieldType == "boolean" then
                            dynamicPlayerData[fieldName] = fieldVal
                        else
                            print("[WARNING] buildSaveState: Player ID '" .. tostring(playerID) .. "' has non-serializable " .. fieldName .. " type: " .. fieldType)
                        end
                    end
                end

                -- Only save if we have at least one dynamic field
                if next(dynamicPlayerData) ~= nil then
                    saveState.playerData[playerID] = dynamicPlayerData
                end
                -- Note: We don't warn if no dynamic fields - player might not have any dynamic state yet
            end
        end
    end

    -- Copy lights data (only serializable fields)
    if gameState.lights then
        saveState.lights = {}
        for lightName, lightData in pairs(gameState.lights) do
            if type(lightData) == "table" then
                -- Light data might be a mode string or a table of per-player modes
                if type(lightData) == "string" then
                    saveState.lights[lightName] = lightData
                else
                    -- Per-player modes - copy only serializable values
                    local cleanLightData = {}
                    for key, val in pairs(lightData) do
                        if type(key) == "string" and (type(val) == "string" or type(val) == "number" or type(val) == "boolean") then
                            cleanLightData[key] = val
                        end
                    end
                    if next(cleanLightData) ~= nil then
                        saveState.lights[lightName] = cleanLightData
                    end
                end
            elseif type(lightData) == "string" then
                saveState.lights[lightName] = lightData
            end
        end
    end

    -- Copy zones data (only serializable fields)
    if gameState.zones then
        saveState.zones = {}
        for zoneKey, zoneData in pairs(gameState.zones) do
            -- Skip non-serializable keys
            if type(zoneKey) ~= "string" and type(zoneKey) ~= "number" then
                -- Skip this key
            elseif type(zoneData) == "string" or type(zoneData) == "number" or type(zoneData) == "boolean" then
                saveState.zones[zoneKey] = zoneData
            elseif type(zoneData) == "table" then
                -- Recursively copy only serializable fields from zone data
                local cleanZoneData = {}
                for k, v in pairs(zoneData) do
                    local kType = type(k)
                    local vType = type(v)

                    -- Keys must be serializable
                    if (kType == "string" or kType == "number") then
                        -- Handle values
                        if vType == "string" or vType == "number" or vType == "boolean" or vType == "nil" then
                            cleanZoneData[k] = v
                        elseif vType == "table" then
                            -- Check if it's a Vector-like table (has x, y, z) and convert to plain table
                            if v.x ~= nil and v.y ~= nil and v.z ~= nil then
                                cleanZoneData[k] = {x = v.x, y = v.y, z = v.z}
                            else
                                -- Plain table - recursively copy (but skip Vector/Color userdata)
                                local nestedClean = {}
                                for nk, nv in pairs(v) do
                                    if (type(nk) == "string" or type(nk) == "number") and
                                       (type(nv) == "string" or type(nv) == "number" or type(nv) == "boolean" or type(nv) == "nil") then
                                        nestedClean[nk] = nv
                                    elseif type(nv) == "table" and nv.x and nv.y and nv.z then
                                        -- Nested Vector-like table
                                        nestedClean[nk] = {x = nv.x, y = nv.y, z = nv.z}
                                    end
                                end
                                if next(nestedClean) ~= nil then
                                    cleanZoneData[k] = nestedClean
                                end
                            end
                        end
                    end
                end
                if next(cleanZoneData) ~= nil then
                    saveState.zones[zoneKey] = cleanZoneData
                end
            end
        end
    end

    -- Copy scene data (only serializable fields)
    if gameState.scene then
        saveState.scene = {}
        if gameState.scene.name then saveState.scene.name = gameState.scene.name end
        if gameState.scene.description then saveState.scene.description = gameState.scene.description end
        if gameState.scene.mood then saveState.scene.mood = gameState.scene.mood end
    end

    return saveState
end

--- Gets the entire game state table (raw or save-safe)
-- @param shouldSanitize boolean Optional. If true, returns explicitly built save state (whitelist approach, default: false)
-- @return table The gameState table (or save-safe version)
-- @usage local state = S.getGameState() -- Get raw state
-- @usage local state = S.getGameState(true) -- Get save-safe state (whitelist approach)
function S.getGameState(shouldSanitize)
    if shouldSanitize then
        return buildSaveState()  -- Use whitelist approach instead of sanitization
    end
    return gameState
end

--- Sets the entire game state table
-- Use with caution - prefer nested get/set functions for individual values.
-- @param data table The new game state table
-- @usage S.setGameState(newState)
function S.setGameState(data)
    gameState = data
    S.validateState()
end

-- ============================================================================
-- STATE VALIDATION
-- ============================================================================

--- Validates that a value is safe to store in game state (JSON-serializable)
-- @param value any The value to validate
-- @param keyPath string Optional. Path for error messages
-- @return boolean True if value is safe to store
local function isValueSafeForState(value, keyPath)
    local valueType = type(value)

    -- Allow primitive types
    if valueType == "number" or valueType == "string" or valueType == "boolean" or valueType == "nil" then
        return true
    end

    -- Check tables recursively
    if valueType == "table" then
        for k, v in pairs(value) do
            local kType = type(k)
            local vType = type(v)

            -- Keys must be string or number
            if kType ~= "string" and kType ~= "number" then
                print("[WARNING] State: Unsafe key type '" .. kType .. "' at " .. (keyPath or "root"))
                return false
            end

            -- Recursively check values
            if not isValueSafeForState(v, (keyPath or "root") .. "." .. tostring(k)) then
                return false
            end
        end
        return true
    end

    -- Reject userdata, functions, threads
    print("[WARNING] State: Attempted to store unsafe type '" .. valueType .. "' at " .. (keyPath or "root") .. " - value will be skipped")
    return false
end

-- ============================================================================
-- PLAYER DATA HELPERS
-- ============================================================================

--- Gets the player ID for a player object or color string
-- Looks up the player ID from C.PlayerData based on the player's color
-- @param playerRef Player|string Player object or color string
-- @return string|nil Player ID if found, nil otherwise
-- @usage local playerID = S.getPlayerID(player) or S.getPlayerID("Red")
function S.getPlayerID(playerRef)
    local playerColor = nil

    -- Extract color from playerRef
    if type(playerRef) == "userdata" then
        -- Assume it's a Player object
        playerColor = playerRef.color
    elseif type(playerRef) == "string" then
        -- Assume it's a color string
        playerColor = playerRef
    else
        return nil
    end

    if not playerColor then
        return nil
    end

    -- Search C.PlayerData for a matching color
    for playerID, playerData in pairs(C.PlayerData) do
        if playerData.color == playerColor then
            return playerID
        end
    end

    return nil
end

--- Gets complete player data (static + dynamic merged) for a player
-- @param playerRef Player|string Player object, color string, or player ID
-- @return table|nil Complete player data if found, nil otherwise
function S.getPlayerData(playerRef)
    local playerID = nil

    -- If it's already a player ID string (exists in C.PlayerData), use it directly
    if type(playerRef) == "string" and C.PlayerData[playerRef] then
        playerID = playerRef
    else
        -- Otherwise, look it up by color
        playerID = S.getPlayerID(playerRef)
    end

    if not playerID then
        return nil
    end

    -- Return the merged player data from gameState
    return gameState.playerData and gameState.playerData[playerID] or nil
end

--- Sets a dynamic player value
-- @param playerRef Player|string Player object, color string, or player ID
-- @param key string The dynamic field name (e.g., "hunger")
-- @param value any The value to set
-- @usage S.setPlayerVal(player, "hunger", 3)
function S.setPlayerVal(playerRef, key, value)
    local playerID = S.getPlayerID(playerRef)

    -- If playerRef is already a player ID, use it directly
    if not playerID and type(playerRef) == "string" and C.PlayerData[playerRef] then
        playerID = playerRef
    end

    if not playerID then
        error("S.setPlayerVal: Could not determine player ID for playerRef: " .. tostring(playerRef))
    end

    S.setStateVal(value, "playerData", playerID, key)
end

--- Gets a dynamic player value
-- @param playerRef Player|string Player object, color string, or player ID
-- @param key string The dynamic field name (e.g., "hunger")
-- @return any The value, or nil if not found
-- @usage local hunger = S.getPlayerVal(player, "hunger")
function S.getPlayerVal(playerRef, key)
    local playerID = S.getPlayerID(playerRef)

    -- If playerRef is already a player ID, use it directly
    if not playerID and type(playerRef) == "string" and C.PlayerData[playerRef] then
        playerID = playerRef
    end

    if not playerID then
        return nil
    end

    return S.getStateVal("playerData", playerID, key)
end

-- ============================================================================
-- NESTED STATE ACCESS (Advanced Get/Set)
-- ============================================================================

--- Gets a nested state value using variable arguments
-- Safely navigates through nested tables. Returns nil if path doesn't exist.
-- @param ... string|number Variable number of keys to navigate through
-- @return any The value at the end of the path, or nil
-- @usage local hunger = S.getStateVal("playerData", playerID, "hunger")
-- @usage local phase = S.getStateVal("currentPhase")
function S.getStateVal(...)
    -- Ensure gameState is initialized
    if gameState == nil then
        print("[WARNING] State: gameState is nil, initializing with defaults")
        gameState = S.GetDefaultGameState()
    end
    return getFromTable(gameState, ...)
end

--- Sets a nested state value using variable arguments
-- Creates intermediate tables automatically if needed.
-- Validates that the value is JSON-serializable before storing.
-- @param value any The value to set (must be JSON-serializable: number, string, boolean, nil, or table of same)
-- @param ... string|number Variable number of keys (last key is where value is set)
-- @usage S.setStateVal(3, "playerData", playerID, "hunger")
-- @usage S.setStateVal("Scene", "currentPhase")
function S.setStateVal(value, ...)
    -- Ensure gameState is initialized
    if gameState == nil then
        print("[WARNING] State: gameState is nil, initializing with defaults")
        gameState = S.GetDefaultGameState()
    end

    -- Validate value is safe to store (JSON-serializable)
    local keys = {...}
    local keyPath = table.concat(keys, ".")
    if not isValueSafeForState(value, keyPath) then
        print("[ERROR] State: Cannot store non-serializable value at path: " .. keyPath)
        return  -- Don't store unsafe values
    end

    setInTable(value, gameState, ...)
end

-- ============================================================================
-- PHASE MANAGEMENT
-- ============================================================================

--- Sets the current game phase
-- Validates that the phase exists in C.Phases before setting.
-- @param phase string The phase to set (should match a value in C.Phases)
-- @usage S.setCurrentPhase(C.Phases.SCENE)
function S.setCurrentPhase(phase)
    -- Validate phase exists
    local isValid = false
    for _, validPhase in pairs(C.Phases) do
        if phase == validPhase then
            isValid = true
            break
        end
    end

    if isValid then
        S.setStateVal(phase, "currentPhase")
        print("State: Game phase set to " .. phase)
    else
        U.AlertGM("Warning: Attempted to set invalid phase: " .. U.ToString(phase))
    end
end

--- Checks if the game is currently in a specific phase
-- @param phase string The phase to check
-- @return boolean True if current phase matches
-- @usage if S.isInPhase(C.Phases.COMBAT) then ... end
function S.isInPhase(phase)
    return S.getStateVal("currentPhase") == phase
end

return S
