--[[
    Debug/Testing Module (core/debug.ttslua)

    Provides testing and debugging utilities for the VTM5E module.
    Functions are exposed globally (assigned without 'local') so they can be called
    from the TTS console using the `lua` command (e.g., `lua testState()`).

    Usage in TTS Console:
        lua testState()              -- Test state management
        lua testScenes()             -- Test scene presets
        lua testUI()                 -- Test UI updates
        lua debugHelp()              -- Show all available debug commands

    NOTE: This module is for development/testing only.
    Consider disabling or restricting access in production builds.
]]

local DEBUG = {}
local U = require("lib.util")
local S = require("core.state")
local M = require("core.main")
local Z = require("core.zones")
local Scenes = require("core.scenes")
local C = require("lib.constants")
local G = require("lib.guids")
local L = require("core.lighting")
local O = require("core.objects")

--[[
    File Logging Configuration
    Uses TTS Tools extension's sendExternalMessage to write debug logs to files
]]
local LOG_DIR = "debug_logs"
local LOG_EXTENSION = "txt"

-- Cache for log file contents (to support append mode)
-- Key: filename (without extension), Value: accumulated content string
local logCache = {}

--[[
    Helper Functions
]]

--- Gets current timestamp as a formatted string
-- @return string Timestamp in format "YYYY-MM-DD HH:MM:SS"
local function getTimestamp()
    local time = os.time()
    -- Lua 5.1 doesn't have os.date with format strings, so we use a workaround
    -- For TTS, we'll use a simpler format
    return tostring(time)
end

--- Writes content to a file in the workspace using TTS Tools extension
-- Supports append mode by maintaining an in-memory cache of file contents
-- @param filename string Name of the file (without extension)
-- @param content string Content to write
-- @param format string Optional format: "auto" (for JSON) or "none" (default: "none")
-- @param append boolean If true, appends to existing cached content (default: true for logs, false for dumps)
local function writeToFile(filename, content, format, append)
    format = format or "none"
    append = append ~= false  -- Default to true (append mode) unless explicitly set to false

    -- Use sendExternalMessage to write to file
    -- Don't set 'object' - that would write to .tts/objects/ directory
    -- Without 'object', files are written to workspace directory
    local fullName = LOG_DIR .. "/" .. filename .. "." .. LOG_EXTENSION

    -- For append mode, maintain cache and accumulate content
    if append then
        if not logCache[filename] then
            logCache[filename] = ""
        end
        logCache[filename] = logCache[filename] .. content
        content = logCache[filename]  -- Write accumulated content
    else
        -- Overwrite mode: clear cache and write new content
        logCache[filename] = content
    end

    -- Check if sendExternalMessage exists (TTS Tools extension)
    ---@diagnostic disable-next-line: undefined-global
    if sendExternalMessage then
        ---@diagnostic disable-next-line: undefined-global
        sendExternalMessage({
            type = "write",
            content = content,
            name = fullName,
            format = format
        })
        print("DEBUG: Log written to " .. fullName)
    else
        -- Fallback: just print if extension not available
        print("DEBUG (file logging not available): " .. filename)
        print(content)
    end
end

--- Prints a formatted test header
-- @param testName string Name of the test
local function printTestHeader(testName)
    print("\n" .. string.rep("=", 60))
    print("TEST: " .. testName)
    print(string.rep("=", 60))
end

--- Prints a formatted test result and logs to file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details about the test
local function printTestResult(testName, passed, details)
    local status = passed and "‚úì PASS" or "‚úó FAIL"
    local color = passed and {0, 1, 0} or {1, 0, 0}
    print(status .. ": " .. testName)
    if details then
        print("  Details: " .. details)
    end

    -- Also log to file
    DEBUG.logTestToFile(testName, passed, details, "test_results")
end

--[[
    State Management Tests
]]

--- Helper: Get the first seated player color
-- Returns the color of the first player that is actually seated/connected
-- Returns nil if no players are seated
-- @return string|nil Player color or nil if no players seated
local function getFirstSeatedPlayerColor()
    for _, color in ipairs(C.PlayerColors) do
        local player = Player[color]
        if player and player.seated then
            return color
        end
    end
    return nil
end

--- Test basic state get/set operations
-- Tests: S.getStateVal, S.setStateVal, nested access
function DEBUG.testState()
    printTestHeader("State Management - Basic Operations")

    -- Reset state to clean defaults before testing
    -- This ensures old saved data doesn't contaminate the tests
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    local passed = 0
    local failed = 0

    -- Test 1: Set and get simple value
    do
        S.setStateVal("test_value", "testKey")
        local result = S.getStateVal("testKey")
        if result == "test_value" then
            printTestResult("Set/Get simple value", true)
            passed = passed + 1
        else
            printTestResult("Set/Get simple value", false, "Expected 'test_value', got '" .. tostring(result) .. "'")
            failed = failed + 1
        end
    end

    -- Test 2: Nested state access
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            local playerID = S.getPlayerID(testColor)
            if playerID then
                S.setPlayerVal(testColor, "hunger", 5)
                local result = S.getPlayerVal(testColor, "hunger")
                if result == 5 then
                    printTestResult("Nested state access", true, "Using player: " .. testColor .. " (ID: " .. playerID .. ")")
                    passed = passed + 1
                else
                    printTestResult("Nested state access", false, "Expected 5, got " .. tostring(result))
                    failed = failed + 1
                end
            else
                printTestResult("Nested state access", false, "Could not find player ID for color: " .. testColor)
                failed = failed + 1
            end
        else
            printTestResult("Nested state access", false, "No seated players found for test")
            failed = failed + 1
        end
    end

    -- Test 3: Get non-existent value (should return nil)
    do
        local result = S.getStateVal("nonExistent", "key")
        if result == nil then
            printTestResult("Get non-existent value returns nil", true)
            passed = passed + 1
        else
            printTestResult("Get non-existent value returns nil", false, "Expected nil, got " .. tostring(result))
            failed = failed + 1
        end
    end

    -- Test 4: Current phase access
    do
        local phase = S.getStateVal("currentPhase")
        printTestResult("Get current phase", phase ~= nil, "Current phase: " .. tostring(phase))
        if phase ~= nil then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 5: mergeDefaults function
    do
        local target = {a = 1, b = {x = 10}}
        local defaults = {b = {y = 20}, c = 3}
        S.mergeDefaults(target, defaults)

        local pass = (target.a == 1 and target.b.x == 10 and target.b.y == 20 and target.c == 3)
        printTestResult("mergeDefaults", pass, pass and "Merged correctly" or "Merge failed")
        if pass then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 6: resetGameState function
    do
        -- Set some values
        S.setStateVal("test", "testKey")
        S.setStateVal(999, "testNumber")

        -- Reset
        S.resetGameState()

        -- Check that test values are gone and defaults are present
        local testValue = S.getStateVal("testKey")
        local defaultPhase = S.getStateVal("currentPhase")

        local pass = (testValue == nil and defaultPhase == C.Phases.SESSION_START)
        printTestResult("resetGameState", pass, pass and "Reset to defaults correctly" or "Reset failed")
        if pass then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 7: Player data merging (mergePlayerData)
    do
        -- This test verifies that static player data from C.PlayerData merges correctly
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            local playerID = S.getPlayerID(testColor)
            if playerID then
                local playerData = S.getPlayerData(testColor)
                -- Player data should have both static (from C.PlayerData) and dynamic (from state) fields
                local hasStatic = playerData and (playerData.color ~= nil or playerData.clan ~= nil)
                local hasDynamic = playerData and playerData.hunger ~= nil

                local pass = (hasStatic and hasDynamic)
                printTestResult("Player data merging", pass, pass and "Static and dynamic data merged" or "Merge failed")
                if pass then passed = passed + 1 else failed = failed + 1 end
            else
                printTestResult("Player data merging", false, "Could not find player ID")
                failed = failed + 1
            end
        else
            printTestResult("Player data merging", false, "No seated players for test")
            failed = failed + 1
        end
    end

    -- Summary
    print("\n" .. string.rep("-", 60))
    print("State Tests: " .. passed .. " passed, " .. failed .. " failed")
    print(string.rep("-", 60))

    -- Log summary to file
    local summary = string.format("State Tests: %d passed, %d failed", passed, failed)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logTestToFile("State Management - Basic Operations", failed == 0, summary, "test_results")
end

--- Test state persistence (save/load)
-- Tests: onSave, JSON encoding/decoding, state restoration
function DEBUG.testStatePersistence()
    printTestHeader("State Management - Persistence")
    DEBUG.logToFile("INFO", "Starting testStatePersistence()", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    -- Set some test values
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("ERROR: No seated players found for persistence test")
        return
    end

    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. testColor)
        return
    end

    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal("PLAY", "currentPhase")
    S.setStateVal("tension", "currentScene")

    -- Get current state
    local stateBefore = S.getGameState()
    print("State before save (using player: " .. testColor .. ", ID: " .. playerID .. "):")
    local playerData = stateBefore.playerData and stateBefore.playerData[playerID]
    print("  " .. testColor .. " hunger: " .. tostring(playerData and playerData.hunger or "nil"))
    print("  Phase: " .. tostring(stateBefore.currentPhase))
    print("  Scene: " .. tostring(stateBefore.currentScene))

    -- Simulate save (encode to JSON)
    local savedData = JSON.encode(stateBefore)
    print("\nSaved data length: " .. #savedData .. " characters")

    -- Simulate load (decode and restore)
    local loadedState = JSON.decode(savedData)
    if loadedState then
        print("\nState after load:")
        local loadedPlayerData = loadedState.playerData and loadedState.playerData[playerID]
        print("  " .. testColor .. " hunger: " .. tostring(loadedPlayerData and loadedPlayerData.hunger or "nil"))
        print("  Phase: " .. tostring(loadedState.currentPhase))
        print("  Scene: " .. tostring(loadedState.currentScene))

        if loadedPlayerData and loadedPlayerData.hunger == 3 and loadedState.currentPhase == "PLAY" then
            printTestResult("State persistence", true, "Values preserved correctly")
        else
            printTestResult("State persistence", false, "Values did not match")
        end
    else
        printTestResult("State persistence", false, "Failed to decode JSON")
    end

    DEBUG.logToFile("INFO", "Completed testStatePersistence()", "debug_log")
end

--[[
    Scene Management Tests
]]

--- Test scene loading and transitions
-- Tests: Scenes.loadScene, Scenes.fadeToScene, Scenes.getCurrentScene
function DEBUG.testScenes()
    printTestHeader("Scene Management")
    DEBUG.logToFile("INFO", "Starting testScenes()", "debug_log")

    -- Test 1: List available scenes
    do
        local scenes = Scenes.listScenes()
        print("Available scenes: " .. table.concat(scenes, ", "))
        printTestResult("List scenes", #scenes > 0, #scenes .. " scenes found")
    end

    -- Test 2: Load a scene
    do
        local success = Scenes.loadScene("elysium")
        printTestResult("Load scene (elysium)", success, success and "Scene loaded" or "Failed to load")
    end

    -- Test 3: Get current scene
    do
        local currentScene = Scenes.getCurrentScene()
        printTestResult("Get current scene", currentScene == "elysium", "Current: " .. tostring(currentScene))
    end

    -- Test 4: Test invalid scene
    do
        local success = Scenes.loadScene("invalid_scene_name")
        printTestResult("Load invalid scene (should fail)", not success, success and "Unexpectedly succeeded" or "Correctly failed")
    end

    -- Test 5: Fade to scene
    do
        print("\nFading to 'alley' scene (2 second transition)...")
        local success = Scenes.fadeToScene("alley", 2.0)
        printTestResult("Fade to scene", success, "Transition started")
    end

    -- Wait a moment and check
    Wait.time(function()
        local currentScene = Scenes.getCurrentScene()
        print("Current scene after fade: " .. tostring(currentScene))
    end, 2.5)

    DEBUG.logToFile("INFO", "Completed testScenes()", "debug_log")
end

--- Test all scene presets
-- Loads each scene preset to verify they work
function DEBUG.testAllScenes()
    printTestHeader("Scene Management - All Presets")
    DEBUG.logToFile("INFO", "Starting testAllScenes()", "debug_log")

    local scenes = Scenes.listScenes()
    local successCount = 0

    for _, sceneName in ipairs(scenes) do
        print("\nTesting scene: " .. sceneName)
        local success = Scenes.loadScene(sceneName)
        if success then
            successCount = successCount + 1
            print("  ‚úì Loaded successfully")
            Wait.time(function() end, 0.5)  -- Brief delay between scenes
        else
            print("  ‚úó Failed to load")
        end
    end

    print("\n" .. string.rep("-", 60))
    print("Scene Tests: " .. successCount .. "/" .. #scenes .. " scenes loaded successfully")
    print(string.rep("-", 60))

    local summary = string.format("Scene Tests: %d/%d scenes loaded successfully", successCount, #scenes)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logToFile("INFO", "Completed testAllScenes()", "debug_log")
end

--[[
    Zone Management Tests
]]

--- Test zone functionality with sequencing and user interaction
-- Tests: Zone activation/deactivation, zone queries, zone events, zone visibility, state persistence
-- Uses U.RunSequence to chain tests with user interaction prompts
function DEBUG.testZones()
    printTestHeader("Zone Management - Comprehensive Test")
    DEBUG.logToFile("INFO", "Starting testZones()", "debug_log")

    local passed = 0
    local failed = 0

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Wait step with broadcast message
    local function waitStep(message, waitTime)
        waitTime = waitTime or 3.0
        return function()
            broadcast(message, {0.7, 0.7, 0.7})
            return waitTime
        end
    end

    -- Helper: Get all scripting zones on the table
    local function getAllZones()
        return U.filter(getObjects(), function(obj)
            return obj.type == "Scripting"
        end)
    end

    -- Helper: Get first zone for testing (or return nil if none exist)
    local function getTestZone()
        local zones = getAllZones()
        return #zones > 0 and zones[1] or nil
    end

    -- Test sequence using U.RunSequence
    local sequenceFunctions = {}

    -- Step 1: Initial broadcast
    table.insert(sequenceFunctions, function()
        broadcast("üó∫Ô∏è  Starting Zone Management Test", {0.5, 0.8, 1})
        return 2.0
    end)

    -- Step 2: Test zone state retrieval
    table.insert(sequenceFunctions, function()
        broadcast("üìä Checking initial zone state...", {0.8, 0.8, 1})
        local zonesLocked = S.getStateVal("zones", "allLocked")
        if zonesLocked == nil then
            -- Initialize zone state if it doesn't exist
            S.setStateVal({allLocked = false}, "zones")
            zonesLocked = false
        end
        print("Current zone state (allLocked): " .. tostring(zonesLocked))
        printTestResult("Get zone state", zonesLocked ~= nil, "State: " .. tostring(zonesLocked))
        if zonesLocked ~= nil then passed = passed + 1 else failed = failed + 1 end
        return 1.0
    end)

    -- Step 3: Test zone activation
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Testing Zone Activation", {0, 1, 0})
        Z.activateZones()
        Wait.time(function()
            local zonesLocked = S.getStateVal("zones", "allLocked")
            local success = zonesLocked == false
            printTestResult("Zone Activation", success, "Zones activated (locked: " .. tostring(zonesLocked) .. ")")
            if success then passed = passed + 1 else failed = failed + 1 end
        end, 0.5)
        return 1.5
    end)

    -- Step 4: Test zone deactivation
    table.insert(sequenceFunctions, function()
        broadcast("‚ùå Testing Zone Deactivation", {1, 0, 0})
        Z.deactivateZones()
        Wait.time(function()
            local zonesLocked = S.getStateVal("zones", "allLocked")
            local success = zonesLocked == true
            printTestResult("Zone Deactivation", success, "Zones deactivated (locked: " .. tostring(zonesLocked) .. ")")
            if success then passed = passed + 1 else failed = failed + 1 end
        end, 0.5)
        return 1.5
    end)

    -- Step 5: Test show zones
    table.insert(sequenceFunctions, function()
        broadcast("üëÅÔ∏è  Testing Show Zones (zones should move above table)", {1, 1, 0})
        Z.showZones()
        printTestResult("Show Zones", true, "Zones shown (check visually - should be above table)")
        passed = passed + 1
        return 2.0  -- Wait for zones to move
    end)

    -- Step 6: Wait after showing zones
    table.insert(sequenceFunctions, waitStep("Zones should now be visible above the table. Waiting 3 seconds...", 3.0))

    -- Step 7: Test hide zones
    table.insert(sequenceFunctions, function()
        broadcast("üôà Testing Hide Zones (zones should move below table)", {0.5, 0.5, 0.5})
        Z.hideZones()
        printTestResult("Hide Zones", true, "Zones hidden (check visually - should be below table)")
        passed = passed + 1
        return 2.0  -- Wait for zones to move
    end)

    -- Step 8: Wait after hiding zones
    table.insert(sequenceFunctions, waitStep("Zones should now be hidden below the table. Waiting 3 seconds...", 3.0))

    -- Step 9: Re-activate zones for event testing
    table.insert(sequenceFunctions, function()
        broadcast("üîÑ Re-activating zones for event testing...", {0.8, 0.8, 1})
        Z.showZones()  -- This also activates zones
        return 2.5  -- Wait for zones to move and activate
    end)

    -- Step 10: Test zone queries - getTaggedZoneObjects
    table.insert(sequenceFunctions, function()
        broadcast("üîç Testing Zone Object Queries", {0.5, 0.8, 1})
        local testZone = getTestZone()
        if testZone then
            -- Test getting all objects in zone
            local allObjects = Z.getTaggedZoneObjects(testZone, "ALL")
            print("Zone '" .. testZone.getName() .. "' contains " .. #allObjects .. " objects")
            printTestResult("getTaggedZoneObjects (ALL)", true, "Found " .. #allObjects .. " objects in zone")
            passed = passed + 1

            -- Test getting objects with specific tag (if any exist)
            if #allObjects > 0 then
                -- Try to find objects with common tags
                local taggedObjects = Z.getTaggedZoneObjects(testZone, "Card")
                if #taggedObjects > 0 then
                    print("  Found " .. #taggedObjects .. " objects with 'Card' tag")
                end
            end
        else
            printTestResult("getTaggedZoneObjects", false, "No zones found for testing")
            failed = failed + 1
        end
        return 1.0
    end)

    -- Step 11: Test zone events - Object Enter Zone (requires user interaction)
    table.insert(sequenceFunctions, function()
        broadcast("üì• Testing Zone Events - Object Enter", {1, 0.8, 0})
        broadcast("   ‚Üí Please place an object INTO a zone now", {1, 1, 0.5})
        broadcast("   ‚Üí Wait for confirmation message...", {0.8, 0.8, 1})

        -- Store initial object count in first zone for comparison
        local testZone = getTestZone()
        local initialCount = 0
        if testZone then
            initialCount = #testZone.getObjects()
        end

        printTestResult("Zone Event - Object Enter", true, "User interaction required - check console for event messages")
        passed = passed + 1  -- We'll test if event fires, but can't auto-detect user action

        return 10.0  -- Give user time to place object
    end)

    -- Step 12: Test zone events - Object Leave Zone (requires user interaction)
    table.insert(sequenceFunctions, function()
        broadcast("üì§ Testing Zone Events - Object Leave", {1, 0.8, 0})
        broadcast("   ‚Üí Please REMOVE an object FROM a zone now", {1, 1, 0.5})
        broadcast("   ‚Üí Wait for confirmation message...", {0.8, 0.8, 1})

        printTestResult("Zone Event - Object Leave", true, "User interaction required - check console for event messages")
        passed = passed + 1

        return 10.0  -- Give user time to remove object
    end)

    -- Step 13: Test zone state persistence - writePosToTaggedObjectsInZone
    table.insert(sequenceFunctions, function()
        broadcast("üíæ Testing Zone State Persistence", {0.8, 0.8, 1})
        local testZone = getTestZone()
        if testZone then
            -- Save positions of all objects in zone
            Z.writePosToTaggedObjectsInZone(testZone, "ALL", "state", "testZones", "savedPositions")
            local savedPos = S.getStateVal("testZones", "savedPositions")
            if savedPos then
                local posCount = 0
                for _ in pairs(savedPos) do posCount = posCount + 1 end
                printTestResult("writePosToTaggedObjectsInZone", posCount > 0, "Saved " .. posCount .. " object positions to state")
                if posCount > 0 then passed = passed + 1 else failed = failed + 1 end
            else
                printTestResult("writePosToTaggedObjectsInZone", false, "No positions saved to state")
                failed = failed + 1
            end
        else
            printTestResult("writePosToTaggedObjectsInZone", false, "No zones found for testing")
            failed = failed + 1
        end
        return 1.0
    end)

    -- Step 14: Final summary
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Zone Management Test Complete!", {0, 1, 0})
        print("\n" .. string.rep("-", 60))
        print("Zone Management Tests: " .. passed .. " passed, " .. failed .. " failed")
        print(string.rep("-", 60))

        local summary = string.format("Zone Management Tests: %d passed, %d failed", passed, failed)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("Zone Management", failed == 0, summary, "test_results")
        return 0  -- No wait needed
    end)

    -- Execute the sequence
    print("Starting zone test sequence with " .. #sequenceFunctions .. " steps...")
    print("This test requires user interaction - watch for broadcast prompts.")
    print("Follow the instructions in the broadcast messages.\n")

    -- Use U.RunSequence to execute all steps
    U.RunSequence(sequenceFunctions)
end

--[[
    Main Module Tests
]]

--- Test main module functions
-- Tests: M.forPlayers, M.setupPlayers, M.advancePhase
function DEBUG.testMain()
    printTestHeader("Main Module")
    DEBUG.logToFile("INFO", "Starting testMain()", "debug_log")

    -- Test 1: forPlayers iteration
    do
        local playerCount = 0
        M.forPlayers(function(player, color)
            playerCount = playerCount + 1
            print("  Found player: " .. color)
        end)
        printTestResult("M.forPlayers iteration", playerCount > 0, playerCount .. " players iterated")
    end

    -- Test 2: Get current phase
    do
        local currentPhase = S.getStateVal("currentPhase")
        print("Current phase: " .. tostring(currentPhase))
        printTestResult("Get current phase", currentPhase ~= nil, "Phase: " .. tostring(currentPhase))
    end

    -- Test 3: Advance phase (if valid)
    do
        local initialPhase = S.getStateVal("currentPhase")
        print("\nCurrent phase: " .. tostring(initialPhase))
        print("Attempting to advance to SCENE phase...")
        M.advancePhase(C.Phases.SCENE)

        Wait.time(function()
            local newPhase = S.getStateVal("currentPhase")
            print("New phase: " .. tostring(newPhase))
            printTestResult("Advance phase", newPhase == C.Phases.SCENE, "Changed to: " .. tostring(newPhase))
        end, 0.1)
    end
end

--[[
    UI Tests
]]

--- Test UI display updates
-- Tests: updateUIDisplays, UI.setValue
function DEBUG.testUI()
    printTestHeader("UI Display Updates")
    DEBUG.logToFile("INFO", "Starting testUI()", "debug_log")

    -- Note: This requires the UI to be loaded and updateUIDisplays to be defined globally

    -- Test 1: Update phase display
    do
        S.setStateVal("PLAY", "currentPhase")
        updateUIDisplays()  -- Call the global function directly
        printTestResult("Update UI phase display", true, "Should update currentPhaseDisplay")
    end

    -- Test 2: Update scene display
    do
        Scenes.loadScene("tension")
        updateUIDisplays()
        printTestResult("Update UI scene display", true, "Should update currentSceneDisplay")
    end

    -- Test 3: Update player stats
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            S.setPlayerVal(testColor, "hunger", 2)
            -- Note: willpower and health are static data in C.PlayerData, not dynamic state
            -- Only hunger is currently saved as dynamic state
            updateUIDisplays()
            printTestResult("Update player stats", true, "Should update " .. testColor .. " player's hunger")
        else
            printTestResult("Update player stats", false, "No seated players found for test")
        end
    end

    print("\nNOTE: Visual verification required - check UI elements in game.")
    DEBUG.logToFile("INFO", "Completed testUI()", "debug_log")
end

--[[
    Constants Module Tests (TOR-3)
]]

--- Test constants module structure and values
-- Tests: C.PlayerColors, C.Phases, G.GUIDS, G.GetHandZoneGUID
function DEBUG.testConstants()
    printTestHeader("Constants Module")
    DEBUG.logToFile("INFO", "Starting testConstants()", "debug_log")

    local passed = 0
    local failed = 0

    -- Test 1: Player Colors
    do
        local expectedColors = {"Brown", "Orange", "Red", "Pink"}
        local allPresent = true
        local missingColors = {}

        for _, expectedColor in ipairs(expectedColors) do
            local found = false
            for _, actualColor in ipairs(C.PlayerColors) do
                if actualColor == expectedColor then
                    found = true
                    break
                end
            end
            if not found then
                allPresent = false
                table.insert(missingColors, expectedColor)
            end
        end

        if allPresent and #C.PlayerColors == #expectedColors then
            print("C.PlayerColors: {" .. table.concat(C.PlayerColors, ", ") .. "}")
            printTestResult("Player Colors", true, "All " .. #expectedColors .. " colors present")
            passed = passed + 1
        else
            local details = "Expected: {" .. table.concat(expectedColors, ", ") .. "}, Got: {" .. table.concat(C.PlayerColors, ", ") .. "}"
            if #missingColors > 0 then
                details = details .. ", Missing: {" .. table.concat(missingColors, ", ") .. "}"
            end
            printTestResult("Player Colors", false, details)
            failed = failed + 1
        end
    end

    -- Test 2: Storyteller Color
    do
        if C.STORYTELLER_COLOR == "Black" then
            print("C.STORYTELLER_COLOR: " .. C.STORYTELLER_COLOR)
            printTestResult("Storyteller Color", true, "Correctly set to Black")
            passed = passed + 1
        else
            printTestResult("Storyteller Color", false, "Expected 'Black', got '" .. tostring(C.STORYTELLER_COLOR) .. "'")
            failed = failed + 1
        end
    end

    -- Test 3: Game Phases
    do
        local expectedPhases = {
            "SessionStart", "Scene", "Downtime", "Combat", "Memoriam", "SessionEnd"
        }
        local allPhasesPresent = true
        local missingPhases = {}

        for _, expectedPhase in ipairs(expectedPhases) do
            local found = false
            for _, actualPhase in pairs(C.Phases) do
                if actualPhase == expectedPhase then
                    found = true
                    break
                end
            end
            if not found then
                allPhasesPresent = false
                table.insert(missingPhases, expectedPhase)
            end
        end

        if allPhasesPresent then
            print("C.Phases: " .. JSON.encode(C.Phases))
            printTestResult("Game Phases", true, "All " .. #expectedPhases .. " phases present")
            passed = passed + 1
        else
            printTestResult("Game Phases", false, "Missing phases: {" .. table.concat(missingPhases, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 4: HAND Zone GUIDs Structure
    do
        local expectedHandKeys = {"HAND_BLACK", "HAND_BROWN", "HAND_ORANGE", "HAND_RED", "HAND_PINK"}
        local allKeysPresent = true
        local missingKeys = {}
        local placeholderCount = 0

        for _, key in ipairs(expectedHandKeys) do
            if G.GUIDS[key] == nil then
                allKeysPresent = false
                table.insert(missingKeys, key)
            elseif string.find(G.GUIDS[key], "@@@@@@") then
                placeholderCount = placeholderCount + 1
            end
        end

        if allKeysPresent then
            local status = placeholderCount > 0 and " (" .. placeholderCount .. " placeholders need GUIDs)" or " (all GUIDs filled)"
            print("HAND Zone GUIDs: All keys present" .. status)
            printTestResult("HAND Zone GUIDs Structure", true, #expectedHandKeys .. " keys present" .. status)
            passed = passed + 1
        else
            printTestResult("HAND Zone GUIDs Structure", false, "Missing keys: {" .. table.concat(missingKeys, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 5: GetHandZoneGUID Function
    do
        local testColors = {"Brown", "Orange", "Red", "Pink", "Black"}
        local allWork = true
        local failedColors = {}

        for _, color in ipairs(testColors) do
            local guid = G.GetHandZoneGUID(color)
            if guid == nil then
                allWork = false
                table.insert(failedColors, color .. " (returned nil)")
            elseif string.find(guid, "@@@@@@") then
                -- This is okay - it's a placeholder that needs to be filled
                print("  " .. color .. ": " .. guid .. " (placeholder - needs GUID)")
            else
                print("  " .. color .. ": " .. guid .. " (GUID filled)")
            end
        end

        if allWork then
            printTestResult("GetHandZoneGUID Function", true, "All colors return valid GUIDs or placeholders")
            passed = passed + 1
        else
            printTestResult("GetHandZoneGUID Function", false, "Failed for: {" .. table.concat(failedColors, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 6: Constants Structure (UI IDs, Dice Settings, etc.)
    do
        local checks = {
            {name = "DICE_SUCCESS_THRESHOLD", value = C.DICE_SUCCESS_THRESHOLD, expected = 6},
            {name = "DICE_CRITICAL_SUCCESS_VALUE", value = C.DICE_CRITICAL_SUCCESS_VALUE, expected = 10},
            {name = "MAX_HUNGER", value = C.MAX_HUNGER, expected = 5},
            {name = "UI_IDS table", value = C.UI_IDS, expected = "table"},
        }

        local allPass = true
        for _, check in ipairs(checks) do
            local pass = false
            if check.expected == "table" then
                pass = type(check.value) == "table"
            else
                pass = check.value == check.expected
            end

            if pass then
                print("  " .. check.name .. ": " .. tostring(check.value))
            else
                print("  " .. check.name .. ": FAILED (expected " .. tostring(check.expected) .. ", got " .. tostring(check.value) .. ")")
                allPass = false
            end
        end

        if allPass then
            printTestResult("Constants Structure", true, "All game settings present")
            passed = passed + 1
        else
            printTestResult("Constants Structure", false, "Some constants missing or incorrect")
            failed = failed + 1
        end
    end

    -- Summary
    print("\n" .. string.rep("-", 60))
    print("Constants Tests: " .. passed .. " passed, " .. failed .. " failed")
    print(string.rep("-", 60))

    local summary = string.format("Constants Tests: %d passed, %d failed", passed, failed)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logTestToFile("Constants Module", failed == 0, summary, "test_results")
end

--[[
    Utility Tests
]]

--- Test utility functions
-- Tests: Basic U.* functions
function DEBUG.testUtilities()
    printTestHeader("Utility Functions")
    DEBUG.logToFile("INFO", "Starting testUtilities()", "debug_log")

    -- Test 1: U.Type
    do
        local result1 = U.Type({})
        local result2 = U.Type("string")
        local result3 = U.Type(123)
        print("U.Type({}): " .. tostring(result1))
        print("U.Type('string'): " .. tostring(result2))
        print("U.Type(123): " .. tostring(result3))
        printTestResult("U.Type", result1 == "table" and result2 == "string" and result3 == "number", "All types correct")
    end

    -- Test 2: U.map
    do
        local input = {1, 2, 3}
        local result = U.map(input, function(x) return x * 2 end)
        local expected = {2, 4, 6}
        local match = result[1] == expected[1] and result[2] == expected[2] and result[3] == expected[3]
        print("U.map({1,2,3}, x*2): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.map", match, "Transformed correctly")
    end

    -- Test 3: U.filter
    do
        local input = {1, 2, 3, 4, 5}
        local result = U.filter(input, function(x) return x % 2 == 0 end)
        print("U.filter({1,2,3,4,5}, even): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.filter", #result == 2 and result[1] == 2 and result[2] == 4, "Filtered correctly")
    end

    DEBUG.logToFile("INFO", "Completed testUtilities()", "debug_log")
end

--[[
    Lighting & Signal Fire Tests (Sequencing & Animation)
]]

--- Initializes all lighting and signal objects to OFF state
-- Sets all signal fires, RING_FLARE, and player lights to OFF instantly
-- Also sets ambient lighting to DARK mode
-- Exposed globally as initLightingAndSignals()
-- @usage initLightingAndSignals() -- Call from TTS console
function DEBUG.initLightingAndSignals()
    print("‚öôÔ∏è  Initializing: Setting all signal fires, hunger smoke, RING_FLARE, player lights to OFF, and ambient to DARK")

    -- NOTE: All object manipulation is done via Objects module
    -- Debug functions should only call other functions, not perform game actions directly

    -- Helper: Convert player color to lighting module light name
    -- Maps "Brown" -> "playerLightBrown", "Orange" -> "playerLightOrange", etc.
    local function getPlayerLightName(color)
        -- Capitalize first letter, lowercase rest
        local first = string.upper(string.sub(color, 1, 1))
        local rest = string.lower(string.sub(color, 2))
        return "playerLight" .. first .. rest
    end

    -- Helper: Set player light mode using lighting module
    -- Uses L.SetLightMode() which handles all properties (position, rotation, range, angle, intensity, enabled)
    local function setPlayerLightMode(color, mode, duration)
        duration = duration or 0.0  -- Default to instant
        local lightName = getPlayerLightName(color)

        if not L or not L.SetLightMode then
            print("‚ö†Ô∏è  Lighting module (L) or SetLightMode not available")
            return false
        end

        if not L.LIGHTMODES[lightName] then
            print("‚ö†Ô∏è  Light mode not found for: " .. lightName)
            return false
        end

        -- Use lighting module to set the mode
        local success, result = pcall(function()
            return L.SetLightMode(lightName, mode, color, duration)
        end)

        if not success then
            print("‚ö†Ô∏è  Error setting player light mode: " .. tostring(result))
            return false
        end

        return true
    end

    local allSuccess = true

    -- Set all signal fires to OFF (instant) - using Objects module
    for _, color in ipairs(C.PlayerColors) do
        local success = O.SetSignalFireState(color, "off", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set all hunger smoke to OFF (instant) - using Objects module
    for _, color in ipairs(C.PlayerColors) do
        local success = O.SetHungerSmokeState(color, "off", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set RING_FLARE to OFF (instant) - using Objects module
    local flareSuccess = O.SetRingFlareState("off", 0.0)  -- 0 = instant
    if not flareSuccess then
        allSuccess = false
    end

    -- Set all player lights to OFF (instant)
    for _, color in ipairs(C.PlayerColors) do
        local success = setPlayerLightMode(color, "OFF", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set ambient lighting to DARK mode (instant)
    if C.LightModes.DARK then
        U.changeLighting(C.LightModes.DARK)
        print("‚úÖ Ambient lighting set to DARK mode")
    else
        print("‚ö†Ô∏è  DARK mode not found in C.LightModes")
        allSuccess = false
    end

    if allSuccess and flareSuccess then
        print("‚úÖ Initialization complete: All objects set to OFF state, ambient lighting set to DARK")
    else
        print("‚ö†Ô∏è  Initialization completed with some errors")
    end
end

--- Helper: Merge partial position with current position
-- Handles partial position updates (e.g., {y=2.5} only changes Y axis)
-- @param obj Object The object to get current position from
-- @param partialPos table Partial position data (e.g., {y=2.5} or {x=1, z=3})
-- @return Vector Complete position with partial values merged
local function mergePosition(obj, partialPos)
    local currentPos = obj.getPosition()
    local newPos = {
        x = partialPos.x or currentPos.x,
        y = partialPos.y or currentPos.y,
        z = partialPos.z or currentPos.z
    }
    return Vector(newPos.x, newPos.y, newPos.z)
end

--- Test lighting and signal fire manipulation with sequencing
-- Tests: Signal fire positioning, lighting changes, U.RunSequence, U.Lerp, broadcasts
function DEBUG.testLightingAndSignals()
    printTestHeader("Lighting & Signal Fire Sequencing Test")
    DEBUG.logToFile("INFO", "Starting testLightingAndSignals()", "debug_log")

    local passed = 0
    local failed = 0

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Wait step with broadcast message
    local function waitStep(message, waitTime)
        waitTime = waitTime or 3.0
        return function()
            broadcast(message, {0.7, 0.7, 0.7})
            return waitTime
        end
    end

    -- NOTE: All object manipulation is done via O module
    -- Debug functions should only call other functions, not perform game actions directly

    -- Helper: Get a random player color for testing
    -- @return string Random player color from C.PlayerColors
    local function getRandomPlayerColor()
        if #C.PlayerColors == 0 then
            return "Brown"  -- Fallback if no colors available
        end
        local randomIndex = math.random(1, #C.PlayerColors)
        return C.PlayerColors[randomIndex]
    end

    -- Helper: Convert player color to lighting module light name
    -- Maps "Brown" -> "playerLightBrown", "Orange" -> "playerLightOrange", etc.
    local function getPlayerLightName(color)
        -- Capitalize first letter, lowercase rest
        local first = string.upper(string.sub(color, 1, 1))
        local rest = string.lower(string.sub(color, 2))
        return "playerLight" .. first .. rest
    end

    -- Helper: Set player light mode using lighting module
    -- Uses L.SetLightMode() which handles all properties (position, rotation, range, angle, intensity, enabled)
    local function setPlayerLightMode(color, mode, duration)
        duration = duration or 0.0  -- Default to instant
        local lightName = getPlayerLightName(color)

        if not L or not L.SetLightMode then
            print("‚ö†Ô∏è  Lighting module (L) or SetLightMode not available")
            return false
        end

        if not L.LIGHTMODES[lightName] then
            print("‚ö†Ô∏è  Light mode not found for: " .. lightName)
            return false
        end

        -- Use lighting module to set the mode
        local success, result = pcall(function()
            return L.SetLightMode(lightName, mode, color, duration)
        end)

        if not success then
            print("‚ö†Ô∏è  Error setting player light mode: " .. tostring(result))
            return false
        end

        return true
    end

    -- Test sequence using U.RunSequence
    local sequenceFunctions = {}

    -- Step 1: Initial broadcast
    table.insert(sequenceFunctions, function()
        broadcast("üî¶ Starting Lighting & Signal Fire Test", {1, 1, 0.5})
        return 2.0
    end)

    -- Step 2: INITIALIZATION - Use the extracted initialization function
    table.insert(sequenceFunctions, function()
        broadcast("‚öôÔ∏è  Initializing: Setting all signal fires, RING_FLARE, player lights to OFF, and ambient to DARK", {0.8, 0.8, 1})

        -- Call the extracted initialization function
        DEBUG.initLightingAndSignals()

        printTestResult("Initialization", true, "All objects set to OFF state, ambient set to DARK")
        passed = passed + 1

        return 1.0  -- Brief pause after initialization
    end)

    -- Step 3: Wait after initialization
    table.insert(sequenceFunctions, waitStep("Initialization complete, waiting 3 seconds...", 3.0))

    -- Step 4: Test signal fire ON (random player)
    table.insert(sequenceFunctions, function()
        local testColor = getRandomPlayerColor()
        broadcast("üî• Testing Signal Fire ON (" .. testColor .. " player)", {1, 0.5, 0})
        local success = O.SetSignalFireState(testColor, "on", 0.2)  -- 0.2 seconds (3x faster)
        if success then
            printTestResult("Signal Fire ON (" .. testColor .. ")", true, "Fire moved to y=1.5")
            passed = passed + 1
        else
            printTestResult("Signal Fire ON (" .. testColor .. ")", false, "Failed to move fire")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 5: Wait after signal fire ON
    table.insert(sequenceFunctions, waitStep("Signal Fire finished raising, waiting 3 seconds...", 3.0))

    -- Step 6: Test signal fire OFF (random player)
    table.insert(sequenceFunctions, function()
        local testColor = getRandomPlayerColor()
        broadcast("üí§ Testing Signal Fire OFF (" .. testColor .. " player)", {0.5, 0.5, 0.5})
        local success = O.SetSignalFireState(testColor, "off", 0.2)  -- 0.2 seconds (3x faster)
        if success then
            printTestResult("Signal Fire OFF (" .. testColor .. ")", true, "Fire moved to y=-7")
            passed = passed + 1
        else
            printTestResult("Signal Fire OFF (" .. testColor .. ")", false, "Failed to move fire")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 7: Wait after signal fire OFF
    table.insert(sequenceFunctions, waitStep("Signal Fire finished lowering, waiting 3 seconds...", 3.0))

    -- Step 8: Test multiple signal fires ON (all player colors)
    table.insert(sequenceFunctions, function()
        broadcast("üî• Testing All Signal Fires ON", {1, 0.5, 0})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetSignalFireState(color, "on", 0.2)  -- 0.2 seconds (3x faster)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Signal Fires ON", true, "All " .. #C.PlayerColors .. " fires activated")
            passed = passed + 1
        else
            printTestResult("All Signal Fires ON", false, "Some fires failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 9: Wait after all signal fires ON
    table.insert(sequenceFunctions, waitStep("All Signal Fires finished raising, waiting 3 seconds...", 3.0))

    -- Step 10: Lerp each player light from OFF to STANDARD (one after another)
    table.insert(sequenceFunctions, function()
        broadcast("üí° Testing Player Lights: OFF ‚Üí STANDARD (sequential)", {1, 1, 0.5})
        local allSuccess = true
        local lerpDuration = 2.0

        -- Create sequence for each player light
        local lightSequence = {}
        for _, color in ipairs(C.PlayerColors) do
            table.insert(lightSequence, function()
                broadcast("  ‚Üí " .. color .. " light transitioning...", {0.8, 0.8, 1})
                local success = setPlayerLightMode(color, "STANDARD", lerpDuration)
                if not success then
                    allSuccess = false
                end
                return lerpDuration + 0.5  -- Wait for animation + brief pause
            end)
        end

        -- Run the sequence of light transitions
        U.RunSequence(lightSequence)

        if allSuccess then
            printTestResult("Player Lights OFF‚ÜíSTANDARD", true, "All " .. #C.PlayerColors .. " lights transitioned")
            passed = passed + 1
        else
            printTestResult("Player Lights OFF‚ÜíSTANDARD", false, "Some lights failed")
            failed = failed + 1
        end

        -- Return total time for all lights (approximate)
        return (lerpDuration + 0.5) * #C.PlayerColors
    end)

    -- Step 11: Wait after player lights transition
    table.insert(sequenceFunctions, waitStep("All Player Lights finished transitioning, waiting 3 seconds...", 3.0))

    -- Step 12: Instantly switch RING_FLARE to ON
    table.insert(sequenceFunctions, function()
        broadcast("‚ú® Testing RING_FLARE: Switching to ON (instant)", {1, 1, 0})
        local success = O.SetRingFlareState("on", 0.0)  -- 0 = instant
        if success then
            printTestResult("RING_FLARE ON", true, "RING_FLARE moved to y=-0.08")
            passed = passed + 1
        else
            printTestResult("RING_FLARE ON", false, "Failed to move RING_FLARE")
            failed = failed + 1
        end
        return 2.0  -- Brief pause to observe
    end)

    -- Step 13: Wait after RING_FLARE ON
    table.insert(sequenceFunctions, waitStep("RING_FLARE switched ON, waiting 3 seconds...", 3.0))

    -- Step 14: Instantly switch RING_FLARE to OFF
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Testing RING_FLARE: Switching to OFF (instant)", {0.5, 0.5, 0.5})
        local success = O.SetRingFlareState("off", 0.0)  -- 0 = instant
        if success then
            printTestResult("RING_FLARE OFF", true, "RING_FLARE moved to y=-60")
            passed = passed + 1
        else
            printTestResult("RING_FLARE OFF", false, "Failed to move RING_FLARE")
            failed = failed + 1
        end
        return 2.0  -- Brief pause to observe
    end)

    -- Step 15: Wait after RING_FLARE OFF
    table.insert(sequenceFunctions, waitStep("RING_FLARE switched OFF, waiting 3 seconds...", 3.0))

    -- Step 16: Simultaneously lerp all player lights from STANDARD to OFF
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Testing Player Lights: STANDARD ‚Üí OFF (simultaneous)", {0.5, 0.5, 0.5})
        local allSuccess = true
        local lerpDuration = 2.0

        -- Start all transitions simultaneously
        for _, color in ipairs(C.PlayerColors) do
            local success = setPlayerLightMode(color, "OFF", lerpDuration)
            if not success then
                allSuccess = false
            end
        end

        if allSuccess then
            printTestResult("Player Lights STANDARD‚ÜíOFF", true, "All " .. #C.PlayerColors .. " lights transitioned simultaneously")
            passed = passed + 1
        else
            printTestResult("Player Lights STANDARD‚ÜíOFF", false, "Some lights failed")
            failed = failed + 1
        end

        return lerpDuration + 1.0  -- Wait for animation to complete
    end)

    -- Step 17: Wait after simultaneous player lights OFF
    table.insert(sequenceFunctions, waitStep("All Player Lights finished transitioning to OFF, waiting 3 seconds...", 3.0))

    -- Step 18: Turn off all signal fires
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Turning Off All Signal Fires", {0.5, 0.5, 0.5})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetSignalFireState(color, "off", 0.2)  -- 0.2 seconds (3x faster)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Signal Fires OFF", true, "All fires deactivated")
            passed = passed + 1
        else
            printTestResult("All Signal Fires OFF", false, "Some fires failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 19: Test hunger smoke ON (Brown player)
    table.insert(sequenceFunctions, function()
        broadcast("üí® Testing Hunger Smoke ON (Brown player)", {0.8, 0.4, 0.8})
        local success = O.SetHungerSmokeState("Brown", "on", 0.2)  -- 0.2 seconds (3x faster)
        if success then
            printTestResult("Hunger Smoke ON (Brown)", true, "Smoke moved to y=0.2")
            passed = passed + 1
        else
            printTestResult("Hunger Smoke ON (Brown)", false, "Failed to move smoke")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 20: Wait after hunger smoke ON
    table.insert(sequenceFunctions, waitStep("Hunger Smoke finished raising, waiting 3 seconds...", 3.0))

    -- Step 21: Test hunger smoke OFF (random player)
    table.insert(sequenceFunctions, function()
        local testColor = getRandomPlayerColor()
        broadcast("üí§ Testing Hunger Smoke OFF (" .. testColor .. " player)", {0.5, 0.5, 0.5})
        local success = O.SetHungerSmokeState(testColor, "off", 0.2)  -- 0.2 seconds (3x faster)
        if success then
            printTestResult("Hunger Smoke OFF (" .. testColor .. ")", true, "Smoke moved to y=-7")
            passed = passed + 1
        else
            printTestResult("Hunger Smoke OFF (" .. testColor .. ")", false, "Failed to move smoke")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 22: Wait after hunger smoke OFF
    table.insert(sequenceFunctions, waitStep("Hunger Smoke finished lowering, waiting 3 seconds...", 3.0))

    -- Step 23: Test all hunger smoke ON (all player colors)
    table.insert(sequenceFunctions, function()
        broadcast("üí® Testing All Hunger Smoke ON", {0.8, 0.4, 0.8})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetHungerSmokeState(color, "on", 0.2)  -- 0.2 seconds (3x faster)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Hunger Smoke ON", true, "All " .. #C.PlayerColors .. " smoke activated")
            passed = passed + 1
        else
            printTestResult("All Hunger Smoke ON", false, "Some smoke failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 24: Wait after all hunger smoke ON
    table.insert(sequenceFunctions, waitStep("All Hunger Smoke finished raising, waiting 3 seconds...", 3.0))

    -- Step 25: Turn off all hunger smoke
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Turning Off All Hunger Smoke", {0.5, 0.5, 0.5})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetHungerSmokeState(color, "off", 0.2)  -- 0.2 seconds (3x faster)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Hunger Smoke OFF", true, "All smoke deactivated")
            passed = passed + 1
        else
            printTestResult("All Hunger Smoke OFF", false, "Some smoke failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 19: Final summary
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Lighting & Signal Fire Test Complete!", {0, 1, 0})
        print("\n" .. string.rep("-", 60))
        print("Lighting & Signal Fire Tests: " .. passed .. " passed, " .. failed .. " failed")
        print(string.rep("-", 60))

        local summary = string.format("Lighting & Signal Fire Tests: %d passed, %d failed", passed, failed)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("Lighting & Signal Fire Sequencing", failed == 0, summary, "test_results")
        return 0  -- No wait needed
    end)

    -- Execute the sequence
    print("Starting sequence test with " .. #sequenceFunctions .. " steps...")
    print("This will take approximately 2-3 minutes to complete.")
    print("Watch for broadcast messages and visual changes.\n")

    -- Use U.RunSequence to execute all steps
    U.RunSequence(sequenceFunctions)
end

--[[
    Test Runner - Run All Tests
]]

--- Run all test functions in sequence
-- Executes all available test functions using U.RunSequence
-- Tests are run in a logical order: foundation tests first, then integration tests
function DEBUG.runTests()
    printTestHeader("Running All Tests")
    DEBUG.logToFile("INFO", "Starting runTests() - Running all test suites", "debug_log")

    local testResults = {}  -- Store results for summary

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Run a single test and capture results
    local function runSingleTest(testName, testFunc)
        broadcast("üß™ Running: " .. testName, {0.8, 0.8, 1})
        print("\n" .. string.rep("=", 60))
        print("TEST SUITE: " .. testName)
        print(string.rep("=", 60))

        -- Note: Individual tests log their own results via logTestToFile
        -- We can't easily capture pass/fail counts from individual tests
        -- So we just run them and let them log
        local success, result = pcall(testFunc)
        if not success then
            print("‚ùå ERROR running " .. testName .. ": " .. tostring(result))
            DEBUG.logToFile("ERROR", "Test " .. testName .. " failed with error: " .. tostring(result), "debug_log")
            return false
        end
        return true
    end

    -- Test sequence
    local testSequence = {}

    -- Step 1: Initial broadcast
    table.insert(testSequence, function()
        broadcast("üöÄ Starting All Tests Suite", {1, 1, 0.5})
        return 2.0
    end)

    -- Step 2: Constants test (foundation)
    table.insert(testSequence, function()
        local success = runSingleTest("Constants Module", DEBUG.testConstants)
        table.insert(testResults, {name = "Constants Module", success = success})
        return 5.0  -- Wait for test to complete
    end)

    -- Step 3: State test (foundation)
    table.insert(testSequence, function()
        local success = runSingleTest("State Management", DEBUG.testState)
        table.insert(testResults, {name = "State Management", success = success})
        return 5.0
    end)

    -- Step 4: Zones test (foundation, with user interaction)
    table.insert(testSequence, function()
        local success = runSingleTest("Zone Management", DEBUG.testZones)
        table.insert(testResults, {name = "Zone Management", success = success})
        return 60.0  -- Zones test requires user interaction, give it more time
    end)

    -- Step 5: Scenes test
    table.insert(testSequence, function()
        local success = runSingleTest("Scene Management", DEBUG.testScenes)
        table.insert(testResults, {name = "Scene Management", success = success})
        return 10.0
    end)

    -- Step 6: Main module test
    table.insert(testSequence, function()
        local success = runSingleTest("Main Module", DEBUG.testMain)
        table.insert(testResults, {name = "Main Module", success = success})
        return 5.0
    end)

    -- Step 7: UI test
    table.insert(testSequence, function()
        local success = runSingleTest("UI Display Updates", DEBUG.testUI)
        table.insert(testResults, {name = "UI Display Updates", success = success})
        return 5.0
    end)

    -- Step 8: Lighting and signals test (long-running with animations)
    table.insert(testSequence, function()
        local success = runSingleTest("Lighting & Signal Fires", DEBUG.testLightingAndSignals)
        table.insert(testResults, {name = "Lighting & Signal Fires", success = success})
        return 180.0  -- Lighting test takes 2-3 minutes
    end)

    -- Step 9: Final summary
    table.insert(testSequence, function()
        broadcast("‚úÖ All Tests Complete!", {0, 1, 0})
        print("\n" .. string.rep("=", 60))
        print("TEST SUITE SUMMARY")
        print(string.rep("=", 60))
        local successCount = 0
        for _, result in ipairs(testResults) do
            local status = result.success and "‚úì" or "‚úó"
            print(status .. " " .. result.name)
            if result.success then successCount = successCount + 1 end
        end
        print(string.rep("-", 60))
        print("Completed: " .. #testResults .. " test suites")
        print("Successful: " .. successCount)
        print("Failed: " .. (#testResults - successCount))
        print(string.rep("=", 60))

        local summary = string.format("All Tests: %d/%d test suites completed successfully", successCount, #testResults)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("All Tests Suite", successCount == #testResults, summary, "test_results")
        return 0
    end)

    -- Execute the sequence
    print("Starting test suite with " .. #testSequence .. " steps...")
    print("This will run all available tests in sequence.")
    print("Some tests require user interaction - watch for broadcast prompts.\n")
    print("Estimated time: 5-10 minutes (depending on user interaction)\n")

    -- Use U.RunSequence to execute all test steps
    U.RunSequence(testSequence)
end

--[[
    Integration Tests
]]

--- Test full module integration
-- Tests that all modules work together
function DEBUG.testIntegration()
    printTestHeader("Full Integration Test")
    DEBUG.logToFile("INFO", "Starting testIntegration() - Running all tests", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    print("Running integration test sequence...")

    -- Step 1: Set game state
    print("\n1. Setting game state...")
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("   ‚úó ERROR: No seated players found for integration test")
        return
    end
    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("   ‚úó ERROR: Could not find player ID for color: " .. testColor)
        return
    end
    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal(C.Phases.SCENE, "currentPhase")
    print("   ‚úì State set (using player: " .. testColor .. ", ID: " .. playerID .. ")")

    -- Step 2: Load scene
    print("\n2. Loading scene...")
    local sceneSuccess = Scenes.loadScene("elysium")
    print("   " .. (sceneSuccess and "‚úì" or "‚úó") .. " Scene loaded")

    -- Step 3: Advance phase
    print("\n3. Advancing phase...")
    M.advancePhase(C.Phases.COMBAT)
    print("   ‚úì Phase advanced")

    -- Step 4: Update UI
    print("\n4. Updating UI...")
    updateUIDisplays()
    print("   ‚úì UI updated")

    -- Step 5: Verify state
    print("\n5. Verifying final state...")
    local finalHunger = S.getPlayerVal(testColor, "hunger")
    local finalPhase = S.getStateVal("currentPhase")
    local finalScene = Scenes.getCurrentScene()

    print("   Final hunger (" .. testColor .. "): " .. tostring(finalHunger))
    print("   Final phase: " .. tostring(finalPhase))
    print("   Final scene: " .. tostring(finalScene))

    local allGood = (finalHunger == 3 and finalPhase == C.Phases.COMBAT and finalScene == "elysium")
    printTestResult("Integration test", allGood, allGood and "All checks passed" or "Some checks failed")
end

--[[
    State Inspection Functions
]]

--- Display current game state (readable format)
function DEBUG.showState()
    printTestHeader("Current Game State")
    local state = S.getGameState()
    print(JSON.encode_pretty(state))
end

--- Logs complete gameState to a file before save
-- Writes both raw and sanitized versions for comparison
-- @param label string Optional label for the dump (default: "gameState_dump")
function DEBUG.logStateToFile(label)
    label = label or "gameState_dump"
    local timestamp = getTimestamp()

    -- Get both raw and sanitized states
    local rawState = S.getGameState(false)
    local sanitizedState = S.getGameState(true)

    -- Build the dump content
    local dumpContent = string.format(
        "=== GAME STATE DUMP: %s ===\nTimestamp: %s\n\n",
        label,
        timestamp
    )

    -- Raw state
    dumpContent = dumpContent .. "--- RAW STATE (gameState) ---\n"
    local rawSuccess, rawJson = pcall(function()
        return JSON.encode_pretty(rawState)
    end)
    if rawSuccess then
        dumpContent = dumpContent .. rawJson .. "\n\n"
    else
        dumpContent = dumpContent .. "ERROR encoding raw state: " .. tostring(rawJson) .. "\n\n"
    end

    -- Sanitized state (what will be saved)
    dumpContent = dumpContent .. "--- SANITIZED STATE (for save) ---\n"
    local sanitizedSuccess, sanitizedJson = pcall(function()
        return JSON.encode_pretty(sanitizedState)
    end)
    if sanitizedSuccess then
        dumpContent = dumpContent .. sanitizedJson .. "\n\n"
    else
        dumpContent = dumpContent .. "ERROR encoding sanitized state: " .. tostring(sanitizedJson) .. "\n\n"
    end

    -- PlayerData structure details
    dumpContent = dumpContent .. "--- PLAYERDATA STRUCTURE DETAILS ---\n"
    if rawState.playerData then
        dumpContent = dumpContent .. "Raw playerData type: " .. type(rawState.playerData) .. "\n"
        dumpContent = dumpContent .. "Raw playerData key count: " .. #U.getKeys(rawState.playerData) .. "\n"
        dumpContent = dumpContent .. "Raw playerData keys: " .. table.concat(U.getKeys(rawState.playerData), ", ") .. "\n\n"

        for playerID, playerData in pairs(rawState.playerData) do
            dumpContent = dumpContent .. string.format("Player[%s]: type=%s\n", tostring(playerID), type(playerData))
            if type(playerData) == "table" then
                dumpContent = dumpContent .. string.format("  Keys: %s\n", table.concat(U.getKeys(playerData), ", "))
                for k, v in pairs(playerData) do
                    dumpContent = dumpContent .. string.format("  [%s] = %s (type: %s)\n", tostring(k), tostring(v), type(v))
                end
            end
            dumpContent = dumpContent .. "\n"
        end
    else
        dumpContent = dumpContent .. "No playerData in raw state\n\n"
    end

    dumpContent = dumpContent .. string.rep("=", 60) .. "\n\n"

    -- Write to file
    DEBUG.logToFile("INFO", dumpContent, "gameState_dump")
end

--- Display current scene info
function DEBUG.showScene()
    printTestHeader("Current Scene Info")
    local currentScene = Scenes.getCurrentScene()
    if currentScene then
        local sceneData = Scenes.getScene(currentScene)
        print("Current Scene: " .. currentScene)
        print("Description: " .. (sceneData.description or "N/A"))
        print("\nScene Data:")
        print(JSON.encode_pretty(sceneData))
    else
        print("No scene currently set.")
    end
end

--- Display zone status
function DEBUG.showZones()
    printTestHeader("Zone Status")
    local zonesLocked = S.getStateVal("zones", "allZonesLocked")
    print("Zones Locked: " .. tostring(zonesLocked))
    print("Zone Events Active: " .. tostring(not zonesLocked))
end

--[[
    Quick Test Functions (Single Commands)
]]

--- Quick test: Set player hunger
-- @param color string Player color
-- @param value number Hunger value (0-5)
function DEBUG.setHunger(color, value)
    if not color or not value then
        print("Usage: setHunger(color, value)")
        print("Example: setHunger('Red', 3)")
        return
    end

    local playerID = S.getPlayerID(color)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. color)
        return
    end

    S.setPlayerVal(color, "hunger", value)
    print("Set " .. color .. " player (ID: " .. playerID .. ") hunger to " .. tostring(value))

    updateUIDisplays()
end

--- Quick test: Change scene
-- @param sceneName string Scene name
function DEBUG.changeScene(sceneName)
    if not sceneName then
        print("Usage: changeScene(sceneName)")
        print("Available scenes: " .. table.concat(Scenes.listScenes(), ", "))
        return
    end

    Scenes.loadScene(sceneName)
    print("Changed scene to: " .. sceneName)
end

--- Quick test: Set phase
-- @param phaseName string Phase name (e.g., "PLAY", "COMBAT")
function DEBUG.setPhase(phaseName)
    if not phaseName then
        print("Usage: setPhase(phaseName)")
        print("Available phases: " .. table.concat(U.getValues(C.Phases), ", "))
        return
    end

    -- Find matching phase constant
    local targetPhase = nil
    for _, phase in pairs(C.Phases) do
        if string.upper(phaseName) == string.upper(phase) or string.upper(phaseName) == string.upper(string.match(phase, "(%w+)$")) then
            targetPhase = phase
            break
        end
    end

    if targetPhase then
        M.advancePhase(targetPhase)
        print("Changed phase to: " .. targetPhase)
    else
        print("Invalid phase name. Available: " .. table.concat(U.getValues(C.Phases), ", "))
    end
end

--[[
    File Logging Functions
    These functions write debug information to files in the workspace using
    the TTS Tools extension's sendExternalMessage API.
]]

--- Logs a message to a file with timestamp
-- @param level string Log level: "INFO", "WARN", "ERROR", "DEBUG"
-- @param message string Message to log
-- @param filename string Optional filename (default: "debug_log")
function DEBUG.logToFile(level, message, filename)
    filename = filename or "debug_log"
    local timestamp = getTimestamp()
    local logEntry = string.format("[%s] [%s] %s\n", timestamp, level, message)

    -- Append to existing cached content
    writeToFile(filename, logEntry, "none", true)
end

--- Logs current game state to a file as JSON
-- @param filename string Optional filename (default: "game_state")
function DEBUG.logStateToFile(filename)
    filename = filename or "game_state"
    local state = S.getGameState()
    local stateJson = JSON.encode_pretty(state)
    local timestamp = getTimestamp()
    local content = string.format("Game State Dump - %s\n%s\n", timestamp, stateJson)

    -- State dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Game state logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs current scene information to a file
-- @param filename string Optional filename (default: "scene_info")
function DEBUG.logSceneToFile(filename)
    filename = filename or "scene_info"
    local currentScene = Scenes.getCurrentScene()
    local scene = Scenes.getScene(currentScene)
    local timestamp = getTimestamp()

    local content = string.format("Scene Information - %s\n", timestamp)
    content = content .. string.format("Current Scene: %s\n", currentScene or "nil")
    if scene then
        content = content .. string.format("Scene Data:\n")
        content = content .. JSON.encode_pretty(scene)
    else
        content = content .. "Scene data not found\n"
    end
    content = content .. "\n"

    -- Scene dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Scene info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs zone information to a file
-- @param filename string Optional filename (default: "zone_info")
function DEBUG.logZonesToFile(filename)
    filename = filename or "zone_info"
    local zonesState = S.getStateVal("zones")
    local timestamp = getTimestamp()

    local content = string.format("Zone Information - %s\n", timestamp)
    if zonesState then
        content = content .. JSON.encode_pretty(zonesState)
    else
        content = content .. "No zone state found\n"
    end
    content = content .. "\n"

    -- Zone dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Zone info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs a test result to a file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details
-- @param filename string Optional filename (default: "test_results")
function DEBUG.logTestToFile(testName, passed, details, filename)
    filename = filename or "test_results"
    local timestamp = getTimestamp()
    local status = passed and "PASS" or "FAIL"

    local content = string.format("[%s] %s: %s\n", timestamp, status, testName)
    if details then
        content = content .. string.format("  Details: %s\n", details)
    end
    content = content .. "\n"

    -- Append to existing cached content
    writeToFile(filename, content, "none", true)
end

--- Logs all debug information to separate files
-- Creates: game_state, scene_info, zone_info, and a general debug log
function DEBUG.logAllToFiles()
    print("DEBUG: Logging all information to files...")
    DEBUG.logStateToFile("game_state")
    DEBUG.logSceneToFile("scene_info")
    DEBUG.logZonesToFile("zone_info")
    DEBUG.logToFile("INFO", "Full debug dump completed", "debug_log")
    print("DEBUG: All logs written to " .. LOG_DIR .. "/ directory")
end

--- Clears all log files (writes empty/header content to reset them)
-- Called automatically on game load to start fresh logs
-- Also clears the in-memory cache
function DEBUG.clearAllLogs()
    local timestamp = getTimestamp()
    local sessionHeader = string.format("=== DEBUG LOG SESSION STARTED - %s ===\n\n", timestamp)

    -- Clear the cache
    logCache = {}

    -- Clear each log file by writing session header (overwrite mode)
    writeToFile("debug_log", sessionHeader, "none", false)
    writeToFile("game_state", sessionHeader, "none", false)
    writeToFile("scene_info", sessionHeader, "none", false)
    writeToFile("zone_info", sessionHeader, "none", false)
    writeToFile("test_results", sessionHeader, "none", false)

    print("DEBUG: All log files cleared (new session started)")
end

--[[
    Help/Documentation
]]

--- Display help for all debug functions
function DEBUG.help()
    print("\n" .. string.rep("=", 70))
    print("VTM5E MODULE - DEBUG/TESTING COMMANDS")
    print(string.rep("=", 70))
    print("\nUse these commands in the TTS console with: lua <command>()")
    print("\nTESTING FUNCTIONS:")
    print("  testConstants()          - Test constants module (TOR-3)")
    print("  testState()              - Test state get/set operations (TOR-5)")
    print("  testStatePersistence()   - Test state save/load")
    print("  testScenes()             - Test scene loading and transitions")
    print("  testAllScenes()          - Test all scene presets")
    print("  testZones()              - Test zone activation/deactivation with user interaction")
    print("  testMain()               - Test main module functions")
    print("  testUI()                 - Test UI display updates")
    print("  testUtilities()          - Test utility functions")
    print("  testLightingAndSignals() - Test lighting & signal fires with sequencing")
    print("  testIntegration()        - Full integration test")
    print("  runTests()               - Run all tests in sequence")
    print("\nINSPECTION FUNCTIONS:")
    print("  showState()              - Display current game state (JSON)")
    print("  showScene()              - Display current scene info")
    print("  showZones()              - Display zone status")
    print("\nFILE LOGGING FUNCTIONS:")
    print("  logToFile(level, msg, filename?) - Log a message to file")
    print("  logStateToFile(filename?)       - Log game state to file (JSON)")
    print("  logSceneToFile(filename?)       - Log scene info to file")
    print("  logZonesToFile(filename?)       - Log zone info to file")
    print("  logTestToFile(name, passed, details?, filename?) - Log test result")
    print("  logAllToFiles()                   - Log all debug info to files")
    print("  clearAllLogs()                    - Clear all log files (starts new session)")
    print("\nQUICK SETTERS:")
    print("  setHunger(color, value)  - Set player hunger (e.g., setHunger('Red', 3))")
    print("  changeScene(sceneName)   - Change scene (e.g., changeScene('elysium'))")
    print("  setPhase(phaseName)      - Change phase (e.g., setPhase('PLAY'))")
    print("\nHELP:")
    print("  debugHelp()              - Show this help message")
    print("\n" .. string.rep("=", 70))
end

--[[
    Expose Functions Globally
    These functions can be called from the TTS console via: lua functionName()
    NOTE: In TTS Lua, assigning without 'local' makes variables global.
    No need for _G syntax - just assign directly.
]]

-- Expose all test functions
testConstants = DEBUG.testConstants
testState = DEBUG.testState
testStatePersistence = DEBUG.testStatePersistence
testScenes = DEBUG.testScenes
testAllScenes = DEBUG.testAllScenes
testZones = DEBUG.testZones
testMain = DEBUG.testMain
testUI = DEBUG.testUI
testUtilities = DEBUG.testUtilities
testLightingAndSignals = DEBUG.testLightingAndSignals
testIntegration = DEBUG.testIntegration
runTests = DEBUG.runTests

-- Expose inspection functions
showState = DEBUG.showState
showScene = DEBUG.showScene
showZones = DEBUG.showZones

-- Expose quick setters
setHunger = DEBUG.setHunger
changeScene = DEBUG.changeScene
setPhase = DEBUG.setPhase

-- Expose file logging functions
logToFile = DEBUG.logToFile
logStateToFile = DEBUG.logStateToFile
logSceneToFile = DEBUG.logSceneToFile
logZonesToFile = DEBUG.logZonesToFile
logTestToFile = DEBUG.logTestToFile
logAllToFiles = DEBUG.logAllToFiles

-- Expose help
debugHelp = DEBUG.help

-- Expose initialization function
initLightingAndSignals = DEBUG.initLightingAndSignals

-- Auto-show help on load (optional - comment out if not desired)
-- DEBUG.help()

return DEBUG
