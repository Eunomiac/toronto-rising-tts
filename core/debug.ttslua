--[[
    Debug/Testing Module (core/debug.ttslua)

    Provides testing and debugging utilities for the VTM5E module.
    Functions are exposed globally (assigned without 'local') so they can be called
    from the TTS console using the `lua` command (e.g., `lua testState()`).

    Usage in TTS Console:
        lua testState()              -- Test state management
        lua testScenes()             -- Test scene presets
        lua testUI()                 -- Test UI updates
        lua debugHelp()              -- Show all available debug commands

    NOTE: This module is for development/testing only.
    Consider disabling or restricting access in production builds.
]]

local DEBUG = {}
local U = require("lib.util")
local S = require("core.state")
local M = require("core.main")
local Z = require("core.zones")
local Scenes = require("core.scenes")
local C = require("lib.constants")

--[[
    File Logging Configuration
    Uses TTS Tools extension's sendExternalMessage to write debug logs to files
]]
local LOG_DIR = "debug_logs"
local LOG_EXTENSION = "txt"

--[[
    Helper Functions
]]

--- Gets current timestamp as a formatted string
-- @return string Timestamp in format "YYYY-MM-DD HH:MM:SS"
local function getTimestamp()
    local time = os.time()
    -- Lua 5.1 doesn't have os.date with format strings, so we use a workaround
    -- For TTS, we'll use a simpler format
    return tostring(time)
end

--- Writes content to a file in the workspace using TTS Tools extension
-- @param filename string Name of the file (without extension)
-- @param content string Content to write
-- @param format string Optional format: "auto" (for JSON) or "none" (default: "none")
local function writeToFile(filename, content, format)
    format = format or "none"

    -- Use sendExternalMessage to write to file
    -- Don't set 'object' - that would write to .tts/objects/ directory
    -- Without 'object', files are written to workspace directory
    local fullName = LOG_DIR .. "/" .. filename .. "." .. LOG_EXTENSION

    -- Check if sendExternalMessage exists (TTS Tools extension)
    ---@diagnostic disable-next-line: undefined-global
    if sendExternalMessage then
        ---@diagnostic disable-next-line: undefined-global
        sendExternalMessage({
            type = "write",
            content = content,
            name = fullName,
            format = format
        })
        print("DEBUG: Log written to " .. fullName)
    else
        -- Fallback: just print if extension not available
        print("DEBUG (file logging not available): " .. filename)
        print(content)
    end
end

--- Prints a formatted test header
-- @param testName string Name of the test
local function printTestHeader(testName)
    print("\n" .. string.rep("=", 60))
    print("TEST: " .. testName)
    print(string.rep("=", 60))
end

--- Prints a formatted test result and logs to file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details about the test
local function printTestResult(testName, passed, details)
    local status = passed and "✓ PASS" or "✗ FAIL"
    local color = passed and {0, 1, 0} or {1, 0, 0}
    print(status .. ": " .. testName)
    if details then
        print("  Details: " .. details)
    end

    -- Also log to file
    DEBUG.logTestToFile(testName, passed, details, "test_results")
end

--[[
    State Management Tests
]]

--- Helper: Get the first seated player color
-- Returns the color of the first player that is actually seated/connected
-- Returns nil if no players are seated
-- @return string|nil Player color or nil if no players seated
local function getFirstSeatedPlayerColor()
    for _, color in ipairs(C.PlayerColors) do
        local player = Player[color]
        if player and player.seated then
            return color
        end
    end
    return nil
end

--- Test basic state get/set operations
-- Tests: S.getStateVal, S.setStateVal, nested access
function DEBUG.testState()
    printTestHeader("State Management - Basic Operations")

    -- Reset state to clean defaults before testing
    -- This ensures old saved data doesn't contaminate the tests
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    local passed = 0
    local failed = 0

    -- Test 1: Set and get simple value
    do
        S.setStateVal("test_value", "testKey")
        local result = S.getStateVal("testKey")
        if result == "test_value" then
            printTestResult("Set/Get simple value", true)
            passed = passed + 1
        else
            printTestResult("Set/Get simple value", false, "Expected 'test_value', got '" .. tostring(result) .. "'")
            failed = failed + 1
        end
    end

    -- Test 2: Nested state access
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            local playerID = S.getPlayerID(testColor)
            if playerID then
                S.setPlayerVal(testColor, "hunger", 5)
                local result = S.getPlayerVal(testColor, "hunger")
                if result == 5 then
                    printTestResult("Nested state access", true, "Using player: " .. testColor .. " (ID: " .. playerID .. ")")
                    passed = passed + 1
                else
                    printTestResult("Nested state access", false, "Expected 5, got " .. tostring(result))
                    failed = failed + 1
                end
            else
                printTestResult("Nested state access", false, "Could not find player ID for color: " .. testColor)
                failed = failed + 1
            end
        else
            printTestResult("Nested state access", false, "No seated players found for test")
            failed = failed + 1
        end
    end

    -- Test 3: Get non-existent value (should return nil)
    do
        local result = S.getStateVal("nonExistent", "key")
        if result == nil then
            printTestResult("Get non-existent value returns nil", true)
            passed = passed + 1
        else
            printTestResult("Get non-existent value returns nil", false, "Expected nil, got " .. tostring(result))
            failed = failed + 1
        end
    end

    -- Test 4: Current phase access
    do
        local phase = S.getStateVal("currentPhase")
        printTestResult("Get current phase", phase ~= nil, "Current phase: " .. tostring(phase))
        if phase ~= nil then passed = passed + 1 else failed = failed + 1 end
    end

    -- Summary
    print("\n" .. string.rep("-", 60))
    print("State Tests: " .. passed .. " passed, " .. failed .. " failed")
    print(string.rep("-", 60))

    -- Log summary to file
    local summary = string.format("State Tests: %d passed, %d failed", passed, failed)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logTestToFile("State Management - Basic Operations", failed == 0, summary, "test_results")
end

--- Test state persistence (save/load)
-- Tests: onSave, JSON encoding/decoding, state restoration
function DEBUG.testStatePersistence()
    printTestHeader("State Management - Persistence")
    DEBUG.logToFile("INFO", "Starting testStatePersistence()", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    -- Set some test values
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("ERROR: No seated players found for persistence test")
        return
    end

    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. testColor)
        return
    end

    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal("PLAY", "currentPhase")
    S.setStateVal("tension", "currentScene")

    -- Get current state
    local stateBefore = S.getGameState()
    print("State before save (using player: " .. testColor .. ", ID: " .. playerID .. "):")
    local playerData = stateBefore.playerData and stateBefore.playerData[playerID]
    print("  " .. testColor .. " hunger: " .. tostring(playerData and playerData.hunger or "nil"))
    print("  Phase: " .. tostring(stateBefore.currentPhase))
    print("  Scene: " .. tostring(stateBefore.currentScene))

    -- Simulate save (encode to JSON)
    local savedData = JSON.encode(stateBefore)
    print("\nSaved data length: " .. #savedData .. " characters")

    -- Simulate load (decode and restore)
    local loadedState = JSON.decode(savedData)
    if loadedState then
        print("\nState after load:")
        local loadedPlayerData = loadedState.playerData and loadedState.playerData[playerID]
        print("  " .. testColor .. " hunger: " .. tostring(loadedPlayerData and loadedPlayerData.hunger or "nil"))
        print("  Phase: " .. tostring(loadedState.currentPhase))
        print("  Scene: " .. tostring(loadedState.currentScene))

        if loadedPlayerData and loadedPlayerData.hunger == 3 and loadedState.currentPhase == "PLAY" then
            printTestResult("State persistence", true, "Values preserved correctly")
        else
            printTestResult("State persistence", false, "Values did not match")
        end
    else
        printTestResult("State persistence", false, "Failed to decode JSON")
    end

    DEBUG.logToFile("INFO", "Completed testStatePersistence()", "debug_log")
end

--[[
    Scene Management Tests
]]

--- Test scene loading and transitions
-- Tests: Scenes.loadScene, Scenes.fadeToScene, Scenes.getCurrentScene
function DEBUG.testScenes()
    printTestHeader("Scene Management")
    DEBUG.logToFile("INFO", "Starting testScenes()", "debug_log")

    -- Test 1: List available scenes
    do
        local scenes = Scenes.listScenes()
        print("Available scenes: " .. table.concat(scenes, ", "))
        printTestResult("List scenes", #scenes > 0, #scenes .. " scenes found")
    end

    -- Test 2: Load a scene
    do
        local success = Scenes.loadScene("elysium")
        printTestResult("Load scene (elysium)", success, success and "Scene loaded" or "Failed to load")
    end

    -- Test 3: Get current scene
    do
        local currentScene = Scenes.getCurrentScene()
        printTestResult("Get current scene", currentScene == "elysium", "Current: " .. tostring(currentScene))
    end

    -- Test 4: Test invalid scene
    do
        local success = Scenes.loadScene("invalid_scene_name")
        printTestResult("Load invalid scene (should fail)", not success, success and "Unexpectedly succeeded" or "Correctly failed")
    end

    -- Test 5: Fade to scene
    do
        print("\nFading to 'alley' scene (2 second transition)...")
        local success = Scenes.fadeToScene("alley", 2.0)
        printTestResult("Fade to scene", success, "Transition started")
    end

    -- Wait a moment and check
    Wait.time(function()
        local currentScene = Scenes.getCurrentScene()
        print("Current scene after fade: " .. tostring(currentScene))
    end, 2.5)

    DEBUG.logToFile("INFO", "Completed testScenes()", "debug_log")
end

--- Test all scene presets
-- Loads each scene preset to verify they work
function DEBUG.testAllScenes()
    printTestHeader("Scene Management - All Presets")
    DEBUG.logToFile("INFO", "Starting testAllScenes()", "debug_log")

    local scenes = Scenes.listScenes()
    local successCount = 0

    for _, sceneName in ipairs(scenes) do
        print("\nTesting scene: " .. sceneName)
        local success = Scenes.loadScene(sceneName)
        if success then
            successCount = successCount + 1
            print("  ✓ Loaded successfully")
            Wait.time(function() end, 0.5)  -- Brief delay between scenes
        else
            print("  ✗ Failed to load")
        end
    end

    print("\n" .. string.rep("-", 60))
    print("Scene Tests: " .. successCount .. "/" .. #scenes .. " scenes loaded successfully")
    print(string.rep("-", 60))

    local summary = string.format("Scene Tests: %d/%d scenes loaded successfully", successCount, #scenes)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logToFile("INFO", "Completed testAllScenes()", "debug_log")
end

--[[
    Zone Management Tests
]]

--- Test zone activation/deactivation
-- Tests: Z.activateZones, Z.deactivateZones, zone state
function DEBUG.testZones()
    printTestHeader("Zone Management")
    DEBUG.logToFile("INFO", "Starting testZones()", "debug_log")

    -- Test 1: Check current zone state
    do
        local zonesLocked = S.getStateVal("zones", "allZonesLocked")
        print("Current zone state (locked): " .. tostring(zonesLocked))
        printTestResult("Get zone state", zonesLocked ~= nil, "State: " .. tostring(zonesLocked))
    end

    -- Test 2: Toggle zones
    do
        local initialState = S.getStateVal("zones", "allZonesLocked")
        if initialState == true then
            print("\nZones are currently locked. Activating...")
            Z.activateZones()
        else
            print("\nZones are currently active. Deactivating...")
            Z.deactivateZones()
        end

        Wait.time(function()
            local newState = S.getStateVal("zones", "allZonesLocked")
            print("New zone state (locked): " .. tostring(newState))
            printTestResult("Toggle zones", newState ~= initialState, "Changed from " .. tostring(initialState) .. " to " .. tostring(newState))
        end, 0.1)
    end

    -- Test 3: Show/hide zones (visual test)
    do
        print("\nHiding zones (moving below table)...")
        Z.hideZones()
        Wait.time(function()
            print("Showing zones (moving above table)...")
            Z.showZones()
        end, 1.0)
    end
end

--[[
    Main Module Tests
]]

--- Test main module functions
-- Tests: M.forPlayers, M.setupPlayers, M.advancePhase
function DEBUG.testMain()
    printTestHeader("Main Module")
    DEBUG.logToFile("INFO", "Starting testMain()", "debug_log")

    -- Test 1: forPlayers iteration
    do
        local playerCount = 0
        M.forPlayers(function(player, color)
            playerCount = playerCount + 1
            print("  Found player: " .. color)
        end)
        printTestResult("M.forPlayers iteration", playerCount > 0, playerCount .. " players iterated")
    end

    -- Test 2: Get current phase
    do
        local currentPhase = S.getStateVal("currentPhase")
        print("Current phase: " .. tostring(currentPhase))
        printTestResult("Get current phase", currentPhase ~= nil, "Phase: " .. tostring(currentPhase))
    end

    -- Test 3: Advance phase (if valid)
    do
        local initialPhase = S.getStateVal("currentPhase")
        print("\nCurrent phase: " .. tostring(initialPhase))
        print("Attempting to advance to SCENE phase...")
        M.advancePhase(C.Phases.SCENE)

        Wait.time(function()
            local newPhase = S.getStateVal("currentPhase")
            print("New phase: " .. tostring(newPhase))
            printTestResult("Advance phase", newPhase == C.Phases.SCENE, "Changed to: " .. tostring(newPhase))
        end, 0.1)
    end
end

--[[
    UI Tests
]]

--- Test UI display updates
-- Tests: updateUIDisplays, UI.setValue
function DEBUG.testUI()
    printTestHeader("UI Display Updates")
    DEBUG.logToFile("INFO", "Starting testUI()", "debug_log")

    -- Note: This requires the UI to be loaded and updateUIDisplays to be defined globally

    -- Test 1: Update phase display
    do
        S.setStateVal("PLAY", "currentPhase")
        updateUIDisplays()  -- Call the global function directly
        printTestResult("Update UI phase display", true, "Should update currentPhaseDisplay")
    end

    -- Test 2: Update scene display
    do
        Scenes.loadScene("tension")
        updateUIDisplays()
        printTestResult("Update UI scene display", true, "Should update currentSceneDisplay")
    end

    -- Test 3: Update player stats
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            S.setPlayerVal(testColor, "hunger", 2)
            -- Note: willpower and health are static data in C.PlayerData, not dynamic state
            -- Only hunger is currently saved as dynamic state
            updateUIDisplays()
            printTestResult("Update player stats", true, "Should update " .. testColor .. " player's hunger")
        else
            printTestResult("Update player stats", false, "No seated players found for test")
        end
    end

    print("\nNOTE: Visual verification required - check UI elements in game.")
    DEBUG.logToFile("INFO", "Completed testUI()", "debug_log")
end

--[[
    Utility Tests
]]

--- Test utility functions
-- Tests: Basic U.* functions
function DEBUG.testUtilities()
    printTestHeader("Utility Functions")
    DEBUG.logToFile("INFO", "Starting testUtilities()", "debug_log")

    -- Test 1: U.Type
    do
        local result1 = U.Type({})
        local result2 = U.Type("string")
        local result3 = U.Type(123)
        print("U.Type({}): " .. tostring(result1))
        print("U.Type('string'): " .. tostring(result2))
        print("U.Type(123): " .. tostring(result3))
        printTestResult("U.Type", result1 == "table" and result2 == "string" and result3 == "number", "All types correct")
    end

    -- Test 2: U.map
    do
        local input = {1, 2, 3}
        local result = U.map(input, function(x) return x * 2 end)
        local expected = {2, 4, 6}
        local match = result[1] == expected[1] and result[2] == expected[2] and result[3] == expected[3]
        print("U.map({1,2,3}, x*2): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.map", match, "Transformed correctly")
    end

    -- Test 3: U.filter
    do
        local input = {1, 2, 3, 4, 5}
        local result = U.filter(input, function(x) return x % 2 == 0 end)
        print("U.filter({1,2,3,4,5}, even): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.filter", #result == 2 and result[1] == 2 and result[2] == 4, "Filtered correctly")
    end

    DEBUG.logToFile("INFO", "Completed testUtilities()", "debug_log")
end

--[[
    Integration Tests
]]

--- Test full module integration
-- Tests that all modules work together
function DEBUG.testIntegration()
    printTestHeader("Full Integration Test")
    DEBUG.logToFile("INFO", "Starting testIntegration() - Running all tests", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    print("Running integration test sequence...")

    -- Step 1: Set game state
    print("\n1. Setting game state...")
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("   ✗ ERROR: No seated players found for integration test")
        return
    end
    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("   ✗ ERROR: Could not find player ID for color: " .. testColor)
        return
    end
    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal(C.Phases.SCENE, "currentPhase")
    print("   ✓ State set (using player: " .. testColor .. ", ID: " .. playerID .. ")")

    -- Step 2: Load scene
    print("\n2. Loading scene...")
    local sceneSuccess = Scenes.loadScene("elysium")
    print("   " .. (sceneSuccess and "✓" or "✗") .. " Scene loaded")

    -- Step 3: Advance phase
    print("\n3. Advancing phase...")
    M.advancePhase(C.Phases.COMBAT)
    print("   ✓ Phase advanced")

    -- Step 4: Update UI
    print("\n4. Updating UI...")
    updateUIDisplays()
    print("   ✓ UI updated")

    -- Step 5: Verify state
    print("\n5. Verifying final state...")
    local finalHunger = S.getPlayerVal(testColor, "hunger")
    local finalPhase = S.getStateVal("currentPhase")
    local finalScene = Scenes.getCurrentScene()

    print("   Final hunger (" .. testColor .. "): " .. tostring(finalHunger))
    print("   Final phase: " .. tostring(finalPhase))
    print("   Final scene: " .. tostring(finalScene))

    local allGood = (finalHunger == 3 and finalPhase == C.Phases.COMBAT and finalScene == "elysium")
    printTestResult("Integration test", allGood, allGood and "All checks passed" or "Some checks failed")
end

--[[
    State Inspection Functions
]]

--- Display current game state (readable format)
function DEBUG.showState()
    printTestHeader("Current Game State")
    local state = S.getGameState()
    print(JSON.encode_pretty(state))
end

--- Logs complete gameState to a file before save
-- Writes both raw and sanitized versions for comparison
-- @param label string Optional label for the dump (default: "gameState_dump")
function DEBUG.logStateToFile(label)
    label = label or "gameState_dump"
    local timestamp = getTimestamp()

    -- Get both raw and sanitized states
    local rawState = S.getGameState(false)
    local sanitizedState = S.getGameState(true)

    -- Build the dump content
    local dumpContent = string.format(
        "=== GAME STATE DUMP: %s ===\nTimestamp: %s\n\n",
        label,
        timestamp
    )

    -- Raw state
    dumpContent = dumpContent .. "--- RAW STATE (gameState) ---\n"
    local rawSuccess, rawJson = pcall(function()
        return JSON.encode_pretty(rawState)
    end)
    if rawSuccess then
        dumpContent = dumpContent .. rawJson .. "\n\n"
    else
        dumpContent = dumpContent .. "ERROR encoding raw state: " .. tostring(rawJson) .. "\n\n"
    end

    -- Sanitized state (what will be saved)
    dumpContent = dumpContent .. "--- SANITIZED STATE (for save) ---\n"
    local sanitizedSuccess, sanitizedJson = pcall(function()
        return JSON.encode_pretty(sanitizedState)
    end)
    if sanitizedSuccess then
        dumpContent = dumpContent .. sanitizedJson .. "\n\n"
    else
        dumpContent = dumpContent .. "ERROR encoding sanitized state: " .. tostring(sanitizedJson) .. "\n\n"
    end

    -- PlayerData structure details
    dumpContent = dumpContent .. "--- PLAYERDATA STRUCTURE DETAILS ---\n"
    if rawState.playerData then
        dumpContent = dumpContent .. "Raw playerData type: " .. type(rawState.playerData) .. "\n"
        dumpContent = dumpContent .. "Raw playerData key count: " .. #U.getKeys(rawState.playerData) .. "\n"
        dumpContent = dumpContent .. "Raw playerData keys: " .. table.concat(U.getKeys(rawState.playerData), ", ") .. "\n\n"

        for playerID, playerData in pairs(rawState.playerData) do
            dumpContent = dumpContent .. string.format("Player[%s]: type=%s\n", tostring(playerID), type(playerData))
            if type(playerData) == "table" then
                dumpContent = dumpContent .. string.format("  Keys: %s\n", table.concat(U.getKeys(playerData), ", "))
                for k, v in pairs(playerData) do
                    dumpContent = dumpContent .. string.format("  [%s] = %s (type: %s)\n", tostring(k), tostring(v), type(v))
                end
            end
            dumpContent = dumpContent .. "\n"
        end
    else
        dumpContent = dumpContent .. "No playerData in raw state\n\n"
    end

    dumpContent = dumpContent .. string.rep("=", 60) .. "\n\n"

    -- Write to file
    DEBUG.logToFile("INFO", dumpContent, "gameState_dump")
end

--- Display current scene info
function DEBUG.showScene()
    printTestHeader("Current Scene Info")
    local currentScene = Scenes.getCurrentScene()
    if currentScene then
        local sceneData = Scenes.getScene(currentScene)
        print("Current Scene: " .. currentScene)
        print("Description: " .. (sceneData.description or "N/A"))
        print("\nScene Data:")
        print(JSON.encode_pretty(sceneData))
    else
        print("No scene currently set.")
    end
end

--- Display zone status
function DEBUG.showZones()
    printTestHeader("Zone Status")
    local zonesLocked = S.getStateVal("zones", "allZonesLocked")
    print("Zones Locked: " .. tostring(zonesLocked))
    print("Zone Events Active: " .. tostring(not zonesLocked))
end

--[[
    Quick Test Functions (Single Commands)
]]

--- Quick test: Set player hunger
-- @param color string Player color
-- @param value number Hunger value (0-5)
function DEBUG.setHunger(color, value)
    if not color or not value then
        print("Usage: setHunger(color, value)")
        print("Example: setHunger('Red', 3)")
        return
    end

    local playerID = S.getPlayerID(color)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. color)
        return
    end

    S.setPlayerVal(color, "hunger", value)
    print("Set " .. color .. " player (ID: " .. playerID .. ") hunger to " .. tostring(value))

    updateUIDisplays()
end

--- Quick test: Change scene
-- @param sceneName string Scene name
function DEBUG.changeScene(sceneName)
    if not sceneName then
        print("Usage: changeScene(sceneName)")
        print("Available scenes: " .. table.concat(Scenes.listScenes(), ", "))
        return
    end

    Scenes.loadScene(sceneName)
    print("Changed scene to: " .. sceneName)
end

--- Quick test: Set phase
-- @param phaseName string Phase name (e.g., "PLAY", "COMBAT")
function DEBUG.setPhase(phaseName)
    if not phaseName then
        print("Usage: setPhase(phaseName)")
        print("Available phases: " .. table.concat(U.getValues(C.Phases), ", "))
        return
    end

    -- Find matching phase constant
    local targetPhase = nil
    for _, phase in pairs(C.Phases) do
        if string.upper(phaseName) == string.upper(phase) or string.upper(phaseName) == string.upper(string.match(phase, "(%w+)$")) then
            targetPhase = phase
            break
        end
    end

    if targetPhase then
        M.advancePhase(targetPhase)
        print("Changed phase to: " .. targetPhase)
    else
        print("Invalid phase name. Available: " .. table.concat(U.getValues(C.Phases), ", "))
    end
end

--[[
    File Logging Functions
    These functions write debug information to files in the workspace using
    the TTS Tools extension's sendExternalMessage API.
]]

--- Logs a message to a file with timestamp
-- @param level string Log level: "INFO", "WARN", "ERROR", "DEBUG"
-- @param message string Message to log
-- @param filename string Optional filename (default: "debug_log")
function DEBUG.logToFile(level, message, filename)
    filename = filename or "debug_log"
    local timestamp = getTimestamp()
    local logEntry = string.format("[%s] [%s] %s\n", timestamp, level, message)

    -- Append to existing file (we'll read existing content first if possible)
    -- For now, we'll create a new entry each time - the extension handles file writing
    writeToFile(filename, logEntry, "none")
end

--- Logs current game state to a file as JSON
-- @param filename string Optional filename (default: "game_state")
function DEBUG.logStateToFile(filename)
    filename = filename or "game_state"
    local state = S.getGameState()
    local stateJson = JSON.encode_pretty(state)
    local timestamp = getTimestamp()
    local content = string.format("Game State Dump - %s\n%s\n", timestamp, stateJson)

    writeToFile(filename, content, "auto")
    print("DEBUG: Game state logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs current scene information to a file
-- @param filename string Optional filename (default: "scene_info")
function DEBUG.logSceneToFile(filename)
    filename = filename or "scene_info"
    local currentScene = Scenes.getCurrentScene()
    local scene = Scenes.getScene(currentScene)
    local timestamp = getTimestamp()

    local content = string.format("Scene Information - %s\n", timestamp)
    content = content .. string.format("Current Scene: %s\n", currentScene or "nil")
    if scene then
        content = content .. string.format("Scene Data:\n")
        content = content .. JSON.encode_pretty(scene)
    else
        content = content .. "Scene data not found\n"
    end
    content = content .. "\n"

    writeToFile(filename, content, "auto")
    print("DEBUG: Scene info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs zone information to a file
-- @param filename string Optional filename (default: "zone_info")
function DEBUG.logZonesToFile(filename)
    filename = filename or "zone_info"
    local zonesState = S.getStateVal("zones")
    local timestamp = getTimestamp()

    local content = string.format("Zone Information - %s\n", timestamp)
    if zonesState then
        content = content .. JSON.encode_pretty(zonesState)
    else
        content = content .. "No zone state found\n"
    end
    content = content .. "\n"

    writeToFile(filename, content, "auto")
    print("DEBUG: Zone info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs a test result to a file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details
-- @param filename string Optional filename (default: "test_results")
function DEBUG.logTestToFile(testName, passed, details, filename)
    filename = filename or "test_results"
    local timestamp = getTimestamp()
    local status = passed and "PASS" or "FAIL"

    local content = string.format("[%s] %s: %s\n", timestamp, status, testName)
    if details then
        content = content .. string.format("  Details: %s\n", details)
    end
    content = content .. "\n"

    writeToFile(filename, content, "none")
end

--- Logs all debug information to separate files
-- Creates: game_state, scene_info, zone_info, and a general debug log
function DEBUG.logAllToFiles()
    print("DEBUG: Logging all information to files...")
    DEBUG.logStateToFile("game_state")
    DEBUG.logSceneToFile("scene_info")
    DEBUG.logZonesToFile("zone_info")
    DEBUG.logToFile("INFO", "Full debug dump completed", "debug_log")
    print("DEBUG: All logs written to " .. LOG_DIR .. "/ directory")
end

--- Clears all log files (writes empty/header content to reset them)
-- Called automatically on game load to start fresh logs
function DEBUG.clearAllLogs()
    local timestamp = getTimestamp()
    local sessionHeader = string.format("=== DEBUG LOG SESSION STARTED - %s ===\n\n", timestamp)

    -- Clear each log file by writing session header
    writeToFile("debug_log", sessionHeader, "none")
    writeToFile("game_state", sessionHeader, "none")
    writeToFile("scene_info", sessionHeader, "none")
    writeToFile("zone_info", sessionHeader, "none")
    writeToFile("test_results", sessionHeader, "none")

    print("DEBUG: All log files cleared (new session started)")
end

--[[
    Help/Documentation
]]

--- Display help for all debug functions
function DEBUG.help()
    print("\n" .. string.rep("=", 70))
    print("VTM5E MODULE - DEBUG/TESTING COMMANDS")
    print(string.rep("=", 70))
    print("\nUse these commands in the TTS console with: lua <command>()")
    print("\nTESTING FUNCTIONS:")
    print("  testState()              - Test state get/set operations")
    print("  testStatePersistence()   - Test state save/load")
    print("  testScenes()             - Test scene loading and transitions")
    print("  testAllScenes()          - Test all scene presets")
    print("  testZones()              - Test zone activation/deactivation")
    print("  testMain()               - Test main module functions")
    print("  testUI()                 - Test UI display updates")
    print("  testUtilities()          - Test utility functions")
    print("  testIntegration()        - Full integration test")
    print("\nINSPECTION FUNCTIONS:")
    print("  showState()              - Display current game state (JSON)")
    print("  showScene()              - Display current scene info")
    print("  showZones()              - Display zone status")
    print("\nFILE LOGGING FUNCTIONS:")
    print("  logToFile(level, msg, filename?) - Log a message to file")
    print("  logStateToFile(filename?)       - Log game state to file (JSON)")
    print("  logSceneToFile(filename?)       - Log scene info to file")
    print("  logZonesToFile(filename?)       - Log zone info to file")
    print("  logTestToFile(name, passed, details?, filename?) - Log test result")
    print("  logAllToFiles()                   - Log all debug info to files")
    print("  clearAllLogs()                    - Clear all log files (starts new session)")
    print("\nQUICK SETTERS:")
    print("  setHunger(color, value)  - Set player hunger (e.g., setHunger('Red', 3))")
    print("  changeScene(sceneName)   - Change scene (e.g., changeScene('elysium'))")
    print("  setPhase(phaseName)      - Change phase (e.g., setPhase('PLAY'))")
    print("\nHELP:")
    print("  debugHelp()              - Show this help message")
    print("\n" .. string.rep("=", 70))
end

--[[
    Expose Functions Globally
    These functions can be called from the TTS console via: lua functionName()
    NOTE: In TTS Lua, assigning without 'local' makes variables global.
    No need for _G syntax - just assign directly.
]]

-- Expose all test functions
testState = DEBUG.testState
testStatePersistence = DEBUG.testStatePersistence
testScenes = DEBUG.testScenes
testAllScenes = DEBUG.testAllScenes
testZones = DEBUG.testZones
testMain = DEBUG.testMain
testUI = DEBUG.testUI
testUtilities = DEBUG.testUtilities
testIntegration = DEBUG.testIntegration

-- Expose inspection functions
showState = DEBUG.showState
showScene = DEBUG.showScene
showZones = DEBUG.showZones

-- Expose quick setters
setHunger = DEBUG.setHunger
changeScene = DEBUG.changeScene
setPhase = DEBUG.setPhase

-- Expose file logging functions
logToFile = DEBUG.logToFile
logStateToFile = DEBUG.logStateToFile
logSceneToFile = DEBUG.logSceneToFile
logZonesToFile = DEBUG.logZonesToFile
logTestToFile = DEBUG.logTestToFile
logAllToFiles = DEBUG.logAllToFiles

-- Expose help
debugHelp = DEBUG.help

-- Auto-show help on load (optional - comment out if not desired)
-- DEBUG.help()

return DEBUG
