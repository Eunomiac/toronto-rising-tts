---@diagnostic disable: lowercase-global
--[[
    Debug/Testing Module (core/debug.ttslua)

    Provides testing and debugging utilities for the VTM5E module.
    Functions are exposed globally (assigned without 'local') so they can be called
    from the TTS console using the `lua` command (e.g., `lua testState()`).

    Usage in TTS Console:
        lua testState()              -- Test state management
        lua testScenes()             -- Test scene presets
        lua testUI()                 -- Test UI updates
        lua debugHelp()              -- Show all available debug commands

    NOTE: This module is for development/testing only.
    Consider disabling or restricting access in production builds.
]]

DEBUG = {}
U = require("lib.util")
S = require("core.state")
M = require("core.main")
Z = require("core.zones")
Scenes = require("core.scenes")
C = require("lib.constants")
G = require("lib.guids")
L = require("core.lighting")
O = require("core.objects")
LightTest = require("core.light_test")

--[[
    File Logging Configuration
    Uses TTS Tools extension's sendExternalMessage to write debug logs to files
]]
local LOG_DIR = "debug_logs"
local LOG_EXTENSION = "txt"

-- Cache for log file contents (to support append mode)
-- Key: filename (without extension), Value: accumulated content string
local logCache = {}

--[[
    Helper Functions
]]

--- Gets current timestamp as a formatted string
-- @return string Timestamp in format "YYYY-MM-DD HH:MM:SS"
local function getTimestamp()
    local time = os.time()
    -- Lua 5.1 doesn't have os.date with format strings, so we use a workaround
    -- For TTS, we'll use a simpler format
    return tostring(time)
end

--- Writes content to a file in the workspace using TTS Tools extension
-- Supports append mode by maintaining an in-memory cache of file contents
-- @param filename string Name of the file (without extension)
-- @param content string Content to write
-- @param format string Optional format: "auto" (for JSON) or "none" (default: "none")
-- @param append boolean If true, appends to existing cached content (default: true for logs, false for dumps)
local function writeToFile(filename, content, format, append)
    format = format or "none"
    append = append ~= false  -- Default to true (append mode) unless explicitly set to false

    -- Use sendExternalMessage to write to file
    -- Don't set 'object' - that would write to .tts/objects/ directory
    -- Without 'object', files are written to workspace directory
    local fullName = LOG_DIR .. "/" .. filename .. "." .. LOG_EXTENSION

    -- For append mode, maintain cache and accumulate content
    if append then
        if not logCache[filename] then
            logCache[filename] = ""
        end
        logCache[filename] = logCache[filename] .. content
        content = logCache[filename]  -- Write accumulated content
    else
        -- Overwrite mode: clear cache and write new content
        logCache[filename] = content
    end

    -- Check if sendExternalMessage exists (TTS Tools extension)
    ---@diagnostic disable-next-line: undefined-global
    if sendExternalMessage then
        ---@diagnostic disable-next-line: undefined-global
        sendExternalMessage({
            type = "write",
            content = content,
            name = fullName,
            format = format
        })
        print("DEBUG: Log written to " .. fullName)
    else
        -- Fallback: just print if extension not available
        print("DEBUG (file logging not available): " .. filename)
        print(content)
    end
end

--- Prints a formatted test header
-- @param testName string Name of the test
local function printTestHeader(testName)
    print("\n" .. string.rep("=", 60))
    print("TEST: " .. testName)
    print(string.rep("=", 60))
end

--- Prints a formatted test result and logs to file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details about the test
local function printTestResult(testName, passed, details)
    local status = passed and "‚úì PASS" or "‚úó FAIL"
    local color = passed and {0, 1, 0} or {1, 0, 0}
    print(status .. ": " .. testName)
    if details then
        print("  Details: " .. details)
    end

    -- Also log to file
    DEBUG.logTestToFile(testName, passed, details, "test_results")
end

--[[
    State Management Tests
]]

--- Helper: Get the first seated player color
-- Returns the color of the first player that is actually seated/connected
-- Returns nil if no players are seated
-- @return string|nil Player color or nil if no players seated
local function getFirstSeatedPlayerColor()
    for _, color in ipairs(C.PlayerColors) do
        local player = Player[color]
        if player and player.seated then
            return color
        end
    end
    return nil
end

--- Test basic state get/set operations
-- Tests: S.getStateVal, S.setStateVal, nested access
function DEBUG.testState()
    printTestHeader("State Management - Basic Operations")

    -- Reset state to clean defaults before testing
    -- This ensures old saved data doesn't contaminate the tests
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    local passed = 0
    local failed = 0

    -- Test 1: Set and get simple value
    do
        S.setStateVal("test_value", "testKey")
        local result = S.getStateVal("testKey")
        if result == "test_value" then
            printTestResult("Set/Get simple value", true)
            passed = passed + 1
        else
            printTestResult("Set/Get simple value", false, "Expected 'test_value', got '" .. tostring(result) .. "'")
            failed = failed + 1
        end
    end

    -- Test 2: Nested state access
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            local playerID = S.getPlayerID(testColor)
            if playerID then
                S.setPlayerVal(testColor, "hunger", 5)
                local result = S.getPlayerVal(testColor, "hunger")
                if result == 5 then
                    printTestResult("Nested state access", true, "Using player: " .. testColor .. " (ID: " .. playerID .. ")")
                    passed = passed + 1
                else
                    printTestResult("Nested state access", false, "Expected 5, got " .. tostring(result))
                    failed = failed + 1
                end
            else
                printTestResult("Nested state access", false, "Could not find player ID for color: " .. testColor)
                failed = failed + 1
            end
        else
            printTestResult("Nested state access", false, "No seated players found for test")
            failed = failed + 1
        end
    end

    -- Test 3: Get non-existent value (should return nil)
    do
        local result = S.getStateVal("nonExistent", "key")
        if result == nil then
            printTestResult("Get non-existent value returns nil", true)
            passed = passed + 1
        else
            printTestResult("Get non-existent value returns nil", false, "Expected nil, got " .. tostring(result))
            failed = failed + 1
        end
    end

    -- Test 4: Current phase access
    do
        local phase = S.getStateVal("currentPhase")
        printTestResult("Get current phase", phase ~= nil, "Current phase: " .. tostring(phase))
        if phase ~= nil then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 5: mergeDefaults function
    do
        local target = {a = 1, b = {x = 10}}
        local defaults = {b = {y = 20}, c = 3}
        S.mergeDefaults(target, defaults)

        local pass = (target.a == 1 and target.b.x == 10 and target.b.y == 20 and target.c == 3)
        printTestResult("mergeDefaults", pass, pass and "Merged correctly" or "Merge failed")
        if pass then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 6: resetGameState function
    do
        -- Set some values
        S.setStateVal("test", "testKey")
        S.setStateVal(999, "testNumber")

        -- Reset
        S.resetGameState()

        -- Check that test values are gone and defaults are present
        local testValue = S.getStateVal("testKey")
        local defaultPhase = S.getStateVal("currentPhase")

        local pass = (testValue == nil and defaultPhase == C.Phases.SESSION_START)
        printTestResult("resetGameState", pass, pass and "Reset to defaults correctly" or "Reset failed")
        if pass then passed = passed + 1 else failed = failed + 1 end
    end

    -- Test 7: Player data merging (mergePlayerData)
    do
        -- This test verifies that static player data from C.PlayerData merges correctly
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            local playerID = S.getPlayerID(testColor)
            if playerID then
                local playerData = S.getPlayerData(testColor)
                -- Player data should have both static (from C.PlayerData) and dynamic (from state) fields
                local hasStatic = playerData and (playerData.color ~= nil or playerData.clan ~= nil)
                local hasDynamic = playerData and playerData.hunger ~= nil

                local pass = (hasStatic and hasDynamic)
                printTestResult("Player data merging", pass, pass and "Static and dynamic data merged" or "Merge failed")
                if pass then passed = passed + 1 else failed = failed + 1 end
            else
                printTestResult("Player data merging", false, "Could not find player ID")
                failed = failed + 1
            end
        else
            printTestResult("Player data merging", false, "No seated players for test")
            failed = failed + 1
        end
    end

    -- Summary
    print("\n" .. string.rep("-", 60))
    print("State Tests: " .. passed .. " passed, " .. failed .. " failed")
    print(string.rep("-", 60))

    -- Log summary to file
    local summary = string.format("State Tests: %d passed, %d failed", passed, failed)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logTestToFile("State Management - Basic Operations", failed == 0, summary, "test_results")
end

--- Test state persistence (save/load)
-- Tests: onSave, JSON encoding/decoding, state restoration
function DEBUG.testStatePersistence()
    printTestHeader("State Management - Persistence")
    DEBUG.logToFile("INFO", "Starting testStatePersistence()", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    -- Set some test values
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("ERROR: No seated players found for persistence test")
        return
    end

    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. testColor)
        return
    end

    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal("PLAY", "currentPhase")
    S.setStateVal("tension", "currentScene")

    -- Get current state
    local stateBefore = S.getGameState()
    print("State before save (using player: " .. testColor .. ", ID: " .. playerID .. "):")
    local playerData = stateBefore.playerData and stateBefore.playerData[playerID]
    print("  " .. testColor .. " hunger: " .. tostring(playerData and playerData.hunger or "nil"))
    print("  Phase: " .. tostring(stateBefore.currentPhase))
    print("  Scene: " .. tostring(stateBefore.currentScene))

    -- Simulate save (encode to JSON)
    local savedData = JSON.encode(stateBefore)
    print("\nSaved data length: " .. #savedData .. " characters")

    -- Simulate load (decode and restore)
    local loadedState = JSON.decode(savedData)
    if loadedState then
        print("\nState after load:")
        local loadedPlayerData = loadedState.playerData and loadedState.playerData[playerID]
        print("  " .. testColor .. " hunger: " .. tostring(loadedPlayerData and loadedPlayerData.hunger or "nil"))
        print("  Phase: " .. tostring(loadedState.currentPhase))
        print("  Scene: " .. tostring(loadedState.currentScene))

        if loadedPlayerData and loadedPlayerData.hunger == 3 and loadedState.currentPhase == "PLAY" then
            printTestResult("State persistence", true, "Values preserved correctly")
        else
            printTestResult("State persistence", false, "Values did not match")
        end
    else
        printTestResult("State persistence", false, "Failed to decode JSON")
    end

    DEBUG.logToFile("INFO", "Completed testStatePersistence()", "debug_log")
end

--[[
    Scene Management Tests
]]

--- Test scene loading and transitions
-- Tests: Scenes.loadScene, Scenes.fadeToScene, Scenes.getCurrentScene
function DEBUG.testScenes()
    printTestHeader("Scene Management")
    DEBUG.logToFile("INFO", "Starting testScenes()", "debug_log")

    -- Test 1: List available scenes
    do
        local scenes = Scenes.listScenes()
        print("Available scenes: " .. table.concat(scenes, ", "))
        printTestResult("List scenes", #scenes > 0, #scenes .. " scenes found")
    end

    -- Test 2: Load a scene
    do
        local success = Scenes.loadScene("elysium")
        printTestResult("Load scene (elysium)", success, success and "Scene loaded" or "Failed to load")
    end

    -- Test 3: Get current scene
    do
        local currentScene = Scenes.getCurrentScene()
        printTestResult("Get current scene", currentScene == "elysium", "Current: " .. tostring(currentScene))
    end

    -- Test 4: Test invalid scene
    do
        local success = Scenes.loadScene("invalid_scene_name")
        printTestResult("Load invalid scene (should fail)", not success, success and "Unexpectedly succeeded" or "Correctly failed")
    end

    -- Test 5: Fade to scene
    do
        print("\nFading to 'alley' scene (2 second transition)...")
        local success = Scenes.fadeToScene("alley", 2.0)
        printTestResult("Fade to scene", success, "Transition started")
    end

    -- Wait a moment and check
    Wait.time(function()
        local currentScene = Scenes.getCurrentScene()
        print("Current scene after fade: " .. tostring(currentScene))
    end, 2.5)

    DEBUG.logToFile("INFO", "Completed testScenes()", "debug_log")
end

--- Test all scene presets
-- Loads each scene preset to verify they work
function DEBUG.testAllScenes()
    printTestHeader("Scene Management - All Presets")
    DEBUG.logToFile("INFO", "Starting testAllScenes()", "debug_log")

    local scenes = Scenes.listScenes()
    local successCount = 0

    for _, sceneName in ipairs(scenes) do
        print("\nTesting scene: " .. sceneName)
        local success = Scenes.loadScene(sceneName)
        if success then
            successCount = successCount + 1
            print("  ‚úì Loaded successfully")
            Wait.time(function() end, 0.5)  -- Brief delay between scenes
        else
            print("  ‚úó Failed to load")
        end
    end

    print("\n" .. string.rep("-", 60))
    print("Scene Tests: " .. successCount .. "/" .. #scenes .. " scenes loaded successfully")
    print(string.rep("-", 60))

    local summary = string.format("Scene Tests: %d/%d scenes loaded successfully", successCount, #scenes)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logToFile("INFO", "Completed testAllScenes()", "debug_log")
end

--[[
    Zone Management Tests
]]

--- Test zone functionality with sequencing and user interaction
-- Tests: Zone activation/deactivation, zone queries, zone events, zone visibility, state persistence
-- Uses U.RunSequence to chain tests with user interaction prompts
function DEBUG.testZones()
    printTestHeader("Zone Management - Comprehensive Test")
    DEBUG.logToFile("INFO", "Starting testZones()", "debug_log")

    local passed = 0
    local failed = 0

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Wait step with broadcast message
    local function waitStep(message, waitTime)
        waitTime = waitTime or 3.0
        return function()
            broadcast(message, {0.7, 0.7, 0.7})
            return waitTime
        end
    end

	-- Helper: Pause until continueTest() is called
	local function pauseStep(message)
		return function()
			broadcast(message, {0.8, 0.8, 1})
			print("üí° To continue, type in console: continueTest()")
			testWaitingForContinue = true
			return function() return testWaitingForContinue == false end
		end
	end

    -- Helper: Get all scripting zones on the table
    local function getAllZones()
        return U.filter(getObjects(), function(obj)
            return obj.type == "Scripting"
        end)
    end

    -- Helper: Get first zone for testing (or return nil if none exist)
    local function getTestZone()
        local zones = getAllZones()
        return #zones > 0 and zones[1] or nil
    end

    -- Test sequence using U.RunSequence
    local sequenceFunctions = {}

    -- Step 1: Initial broadcast
    table.insert(sequenceFunctions, function()
        broadcast("üó∫Ô∏è  Starting Zone Management Test", {0.5, 0.8, 1})
        return 2.0
    end)

    -- Step 2: Test zone state retrieval
    table.insert(sequenceFunctions, function()
        broadcast("üìä Checking initial zone state...", {0.8, 0.8, 1})
        local zonesLocked = S.getStateVal("zones", "allLocked")
        if zonesLocked == nil then
            -- Initialize zone state if it doesn't exist
            S.setStateVal({allLocked = false}, "zones")
            zonesLocked = false
        end
        print("Current zone state (allLocked): " .. tostring(zonesLocked))
        printTestResult("Get zone state", zonesLocked ~= nil, "State: " .. tostring(zonesLocked))
        if zonesLocked ~= nil then passed = passed + 1 else failed = failed + 1 end
        return 1.0
    end)

    -- Step 3: Test zone activation
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Testing Zone Activation", {0, 1, 0})
        Z.activateZones()
        Wait.time(function()
            local zonesLocked = S.getStateVal("zones", "allLocked")
            local success = zonesLocked == false
            printTestResult("Zone Activation", success, "Zones activated (locked: " .. tostring(zonesLocked) .. ")")
            if success then passed = passed + 1 else failed = failed + 1 end
        end, 0.5)
        return 1.5
    end)

    -- Step 4: Test zone deactivation
    table.insert(sequenceFunctions, function()
        broadcast("‚ùå Testing Zone Deactivation", {1, 0, 0})
        Z.deactivateZones()
        Wait.time(function()
            local zonesLocked = S.getStateVal("zones", "allLocked")
            local success = zonesLocked == true
            printTestResult("Zone Deactivation", success, "Zones deactivated (locked: " .. tostring(zonesLocked) .. ")")
            if success then passed = passed + 1 else failed = failed + 1 end
        end, 0.5)
        return 1.5
    end)

    -- Step 5: Test show zones
    table.insert(sequenceFunctions, function()
        broadcast("üëÅÔ∏è  Testing Show Zones (zones should move above table)", {1, 1, 0})
        Z.showZones()
        printTestResult("Show Zones", true, "Zones shown (check visually - should be above table)")
        passed = passed + 1
        return 2.0  -- Wait for zones to move
    end)

    -- Step 6: Wait after showing zones
    table.insert(sequenceFunctions, waitStep("Zones should now be visible above the table. Waiting 3 seconds...", 3.0))

    -- Step 7: Test hide zones
    table.insert(sequenceFunctions, function()
        broadcast("üôà Testing Hide Zones (zones should move below table)", {0.5, 0.5, 0.5})
        Z.hideZones()
        printTestResult("Hide Zones", true, "Zones hidden (check visually - should be below table)")
        passed = passed + 1
        return 2.0  -- Wait for zones to move
    end)

    -- Step 8: Wait after hiding zones
    table.insert(sequenceFunctions, waitStep("Zones should now be hidden below the table. Waiting 3 seconds...", 3.0))

    -- Step 9: Re-activate zones for event testing
    table.insert(sequenceFunctions, function()
        broadcast("üîÑ Re-activating zones for event testing...", {0.8, 0.8, 1})
        Z.showZones()  -- This also activates zones
        return 2.5  -- Wait for zones to move and activate
    end)

    -- Step 10: Test zone queries - getTaggedZoneObjects
    table.insert(sequenceFunctions, function()
        broadcast("üîç Testing Zone Object Queries", {0.5, 0.8, 1})
        local testZone = getTestZone()
        if testZone then
            -- Test getting all objects in zone
            local allObjects = Z.getTaggedZoneObjects(testZone, "ALL")
            print("Zone '" .. testZone.getName() .. "' contains " .. #allObjects .. " objects")
            printTestResult("getTaggedZoneObjects (ALL)", true, "Found " .. #allObjects .. " objects in zone")
            passed = passed + 1

            -- Test getting objects with specific tag (if any exist)
            if #allObjects > 0 then
                -- Try to find objects with common tags
                local taggedObjects = Z.getTaggedZoneObjects(testZone, "Card")
                if #taggedObjects > 0 then
                    print("  Found " .. #taggedObjects .. " objects with 'Card' tag")
                end
            end
        else
            printTestResult("getTaggedZoneObjects", false, "No zones found for testing")
            failed = failed + 1
        end
        return 1.0
    end)

    -- Step 11: Test zone events - Object Enter Zone (requires user interaction)
    table.insert(sequenceFunctions, function()
        broadcast("üì• Testing Zone Events - Object Enter", {1, 0.8, 0})
        broadcast("   ‚Üí Please place an object INTO a zone now", {1, 1, 0.5})
        broadcast("   ‚Üí Wait for confirmation message...", {0.8, 0.8, 1})

        -- Store initial object count in first zone for comparison
        local testZone = getTestZone()
        local initialCount = 0
        if testZone then
            initialCount = #testZone.getObjects()
        end

        printTestResult("Zone Event - Object Enter", true, "User interaction required - check console for event messages")
        passed = passed + 1  -- We'll test if event fires, but can't auto-detect user action

        return 10.0  -- Give user time to place object
    end)

    -- Step 12: Test zone events - Object Leave Zone (requires user interaction)
    table.insert(sequenceFunctions, function()
        broadcast("üì§ Testing Zone Events - Object Leave", {1, 0.8, 0})
        broadcast("   ‚Üí Please REMOVE an object FROM a zone now", {1, 1, 0.5})
        broadcast("   ‚Üí Wait for confirmation message...", {0.8, 0.8, 1})

        printTestResult("Zone Event - Object Leave", true, "User interaction required - check console for event messages")
        passed = passed + 1

        return 10.0  -- Give user time to remove object
    end)

    -- Step 13: Test zone state persistence - writePosToTaggedObjectsInZone
    table.insert(sequenceFunctions, function()
        broadcast("üíæ Testing Zone State Persistence", {0.8, 0.8, 1})
        local testZone = getTestZone()
        if testZone then
            -- Save positions of all objects in zone
            Z.writePosToTaggedObjectsInZone(testZone, "ALL", "state", "testZones", "savedPositions")
            local savedPos = S.getStateVal("testZones", "savedPositions")
            if savedPos then
                local posCount = 0
                for _ in pairs(savedPos) do posCount = posCount + 1 end
                printTestResult("writePosToTaggedObjectsInZone", posCount > 0, "Saved " .. posCount .. " object positions to state")
                if posCount > 0 then passed = passed + 1 else failed = failed + 1 end
            else
                printTestResult("writePosToTaggedObjectsInZone", false, "No positions saved to state")
                failed = failed + 1
            end
        else
            printTestResult("writePosToTaggedObjectsInZone", false, "No zones found for testing")
            failed = failed + 1
        end
        return 1.0
    end)

    -- Step 14: Final summary
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Zone Management Test Complete!", {0, 1, 0})
        print("\n" .. string.rep("-", 60))
        print("Zone Management Tests: " .. passed .. " passed, " .. failed .. " failed")
        print(string.rep("-", 60))

        local summary = string.format("Zone Management Tests: %d passed, %d failed", passed, failed)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("Zone Management", failed == 0, summary, "test_results")
        return 0  -- No wait needed
    end)

    -- Execute the sequence
    print("Starting zone test sequence with " .. #sequenceFunctions .. " steps...")
    print("This test requires user interaction - watch for broadcast prompts.")
    print("Follow the instructions in the broadcast messages.\n")

    -- Use U.RunSequence to execute all steps
    U.RunSequence(sequenceFunctions)
end

--[[
    Main Module Tests
]]

--- Test main module functions
-- Tests: M.forPlayers, M.setupPlayers, M.advancePhase
function DEBUG.testMain()
    printTestHeader("Main Module")
    DEBUG.logToFile("INFO", "Starting testMain()", "debug_log")

    -- Test 1: forPlayers iteration
    do
        local playerCount = 0
        M.forPlayers(function(player, color)
            playerCount = playerCount + 1
            print("  Found player: " .. color)
        end)
        printTestResult("M.forPlayers iteration", playerCount > 0, playerCount .. " players iterated")
    end

    -- Test 2: Get current phase
    do
        local currentPhase = S.getStateVal("currentPhase")
        print("Current phase: " .. tostring(currentPhase))
        printTestResult("Get current phase", currentPhase ~= nil, "Phase: " .. tostring(currentPhase))
    end

    -- Test 3: Advance phase (if valid)
    do
        local initialPhase = S.getStateVal("currentPhase")
        print("\nCurrent phase: " .. tostring(initialPhase))
        print("Attempting to advance to SCENE phase...")
        M.advancePhase(C.Phases.SCENE)

        Wait.time(function()
            local newPhase = S.getStateVal("currentPhase")
            print("New phase: " .. tostring(newPhase))
            printTestResult("Advance phase", newPhase == C.Phases.SCENE, "Changed to: " .. tostring(newPhase))
        end, 0.1)
    end
end

--[[
    UI Tests
]]

--- Test UI display updates
-- Tests: updateUIDisplays, UI.setValue
function DEBUG.testUI()
    printTestHeader("UI Display Updates")
    DEBUG.logToFile("INFO", "Starting testUI()", "debug_log")

    -- Note: This requires the UI to be loaded and updateUIDisplays to be defined globally

    -- Test 1: Update phase display
    do
        S.setStateVal("PLAY", "currentPhase")
        updateUIDisplays()  -- Call the global function directly
        printTestResult("Update UI phase display", true, "Should update currentPhaseDisplay")
    end

    -- Test 2: Update scene display
    do
        Scenes.loadScene("tension")
        updateUIDisplays()
        printTestResult("Update UI scene display", true, "Should update currentSceneDisplay")
    end

    -- Test 3: Update player stats
    do
        local testColor = getFirstSeatedPlayerColor()
        if testColor then
            S.setPlayerVal(testColor, "hunger", 2)
            -- Note: willpower and health are static data in C.PlayerData, not dynamic state
            -- Only hunger is currently saved as dynamic state
            updateUIDisplays()
            printTestResult("Update player stats", true, "Should update " .. testColor .. " player's hunger")
        else
            printTestResult("Update player stats", false, "No seated players found for test")
        end
    end

    print("\nNOTE: Visual verification required - check UI elements in game.")
    DEBUG.logToFile("INFO", "Completed testUI()", "debug_log")
end

--[[
    Constants Module Tests (TOR-3)
]]

--- Test constants module structure and values
-- Tests: C.PlayerColors, C.Phases, G.GUIDS, G.GetHandZoneGUID
function DEBUG.testConstants()
    printTestHeader("Constants Module")
    DEBUG.logToFile("INFO", "Starting testConstants()", "debug_log")

    local passed = 0
    local failed = 0

    -- Test 1: Player Colors
    do
        local expectedColors = {"Brown", "Orange", "Red", "Pink"}
        local allPresent = true
        local missingColors = {}

        for _, expectedColor in ipairs(expectedColors) do
            local found = false
            for _, actualColor in ipairs(C.PlayerColors) do
                if actualColor == expectedColor then
                    found = true
                    break
                end
            end
            if not found then
                allPresent = false
                table.insert(missingColors, expectedColor)
            end
        end

        if allPresent and #C.PlayerColors == #expectedColors then
            print("C.PlayerColors: {" .. table.concat(C.PlayerColors, ", ") .. "}")
            printTestResult("Player Colors", true, "All " .. #expectedColors .. " colors present")
            passed = passed + 1
        else
            local details = "Expected: {" .. table.concat(expectedColors, ", ") .. "}, Got: {" .. table.concat(C.PlayerColors, ", ") .. "}"
            if #missingColors > 0 then
                details = details .. ", Missing: {" .. table.concat(missingColors, ", ") .. "}"
            end
            printTestResult("Player Colors", false, details)
            failed = failed + 1
        end
    end

    -- Test 2: Storyteller Color
    do
        if C.STORYTELLER_COLOR == "Black" then
            print("C.STORYTELLER_COLOR: " .. C.STORYTELLER_COLOR)
            printTestResult("Storyteller Color", true, "Correctly set to Black")
            passed = passed + 1
        else
            printTestResult("Storyteller Color", false, "Expected 'Black', got '" .. tostring(C.STORYTELLER_COLOR) .. "'")
            failed = failed + 1
        end
    end

    -- Test 3: Game Phases
    do
        local expectedPhases = {
            "SessionStart", "Scene", "Downtime", "Combat", "Memoriam", "SessionEnd"
        }
        local allPhasesPresent = true
        local missingPhases = {}

        for _, expectedPhase in ipairs(expectedPhases) do
            local found = false
            for _, actualPhase in pairs(C.Phases) do
                if actualPhase == expectedPhase then
                    found = true
                    break
                end
            end
            if not found then
                allPhasesPresent = false
                table.insert(missingPhases, expectedPhase)
            end
        end

        if allPhasesPresent then
            print("C.Phases: " .. JSON.encode(C.Phases))
            printTestResult("Game Phases", true, "All " .. #expectedPhases .. " phases present")
            passed = passed + 1
        else
            printTestResult("Game Phases", false, "Missing phases: {" .. table.concat(missingPhases, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 4: HAND Zone GUIDs Structure
    do
        local expectedHandKeys = {"HAND_BLACK", "HAND_BROWN", "HAND_ORANGE", "HAND_RED", "HAND_PINK"}
        local allKeysPresent = true
        local missingKeys = {}
        local placeholderCount = 0

        for _, key in ipairs(expectedHandKeys) do
            if G.GUIDS[key] == nil then
                allKeysPresent = false
                table.insert(missingKeys, key)
            elseif string.find(G.GUIDS[key], "@@@@@@") then
                placeholderCount = placeholderCount + 1
            end
        end

        if allKeysPresent then
            local status = placeholderCount > 0 and " (" .. placeholderCount .. " placeholders need GUIDs)" or " (all GUIDs filled)"
            print("HAND Zone GUIDs: All keys present" .. status)
            printTestResult("HAND Zone GUIDs Structure", true, #expectedHandKeys .. " keys present" .. status)
            passed = passed + 1
        else
            printTestResult("HAND Zone GUIDs Structure", false, "Missing keys: {" .. table.concat(missingKeys, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 5: GetHandZoneGUID Function
    do
        local testColors = {"Brown", "Orange", "Red", "Pink", "Black"}
        local allWork = true
        local failedColors = {}

        for _, color in ipairs(testColors) do
            local guid = G.GetHandZoneGUID(color)
            if guid == nil then
                allWork = false
                table.insert(failedColors, color .. " (returned nil)")
            elseif string.find(guid, "@@@@@@") then
                -- This is okay - it's a placeholder that needs to be filled
                print("  " .. color .. ": " .. guid .. " (placeholder - needs GUID)")
            else
                print("  " .. color .. ": " .. guid .. " (GUID filled)")
            end
        end

        if allWork then
            printTestResult("GetHandZoneGUID Function", true, "All colors return valid GUIDs or placeholders")
            passed = passed + 1
        else
            printTestResult("GetHandZoneGUID Function", false, "Failed for: {" .. table.concat(failedColors, ", ") .. "}")
            failed = failed + 1
        end
    end

    -- Test 6: Constants Structure (UI IDs, Dice Settings, etc.)
    do
        local checks = {
            {name = "DICE_SUCCESS_THRESHOLD", value = C.DICE_SUCCESS_THRESHOLD, expected = 6},
            {name = "DICE_CRITICAL_SUCCESS_VALUE", value = C.DICE_CRITICAL_SUCCESS_VALUE, expected = 10},
            {name = "MAX_HUNGER", value = C.MAX_HUNGER, expected = 5},
            {name = "UI_IDS table", value = C.UI_IDS, expected = "table"},
        }

        local allPass = true
        for _, check in ipairs(checks) do
            local pass = false
            if check.expected == "table" then
                pass = type(check.value) == "table"
            else
                pass = check.value == check.expected
            end

            if pass then
                print("  " .. check.name .. ": " .. tostring(check.value))
            else
                print("  " .. check.name .. ": FAILED (expected " .. tostring(check.expected) .. ", got " .. tostring(check.value) .. ")")
                allPass = false
            end
        end

        if allPass then
            printTestResult("Constants Structure", true, "All game settings present")
            passed = passed + 1
        else
            printTestResult("Constants Structure", false, "Some constants missing or incorrect")
            failed = failed + 1
        end
    end

    -- Summary
    print("\n" .. string.rep("-", 60))
    print("Constants Tests: " .. passed .. " passed, " .. failed .. " failed")
    print(string.rep("-", 60))

    local summary = string.format("Constants Tests: %d passed, %d failed", passed, failed)
    DEBUG.logToFile("INFO", summary, "debug_log")
    DEBUG.logTestToFile("Constants Module", failed == 0, summary, "test_results")
end

--[[
    Utility Tests
]]

--- Test utility functions
-- Tests: Basic U.* functions
function DEBUG.testUtilities()
    printTestHeader("Utility Functions")
    DEBUG.logToFile("INFO", "Starting testUtilities()", "debug_log")

    -- Test 1: U.Type
    do
        local result1 = U.Type({})
        local result2 = U.Type("string")
        local result3 = U.Type(123)
        print("U.Type({}): " .. tostring(result1))
        print("U.Type('string'): " .. tostring(result2))
        print("U.Type(123): " .. tostring(result3))
        printTestResult("U.Type", result1 == "table" and result2 == "string" and result3 == "number", "All types correct")
    end

    -- Test 2: U.map
    do
        local input = {1, 2, 3}
        local result = U.map(input, function(x) return x * 2 end)
        local expected = {2, 4, 6}
        local match = result[1] == expected[1] and result[2] == expected[2] and result[3] == expected[3]
        print("U.map({1,2,3}, x*2): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.map", match, "Transformed correctly")
    end

    -- Test 3: U.filter
    do
        local input = {1, 2, 3, 4, 5}
        local result = U.filter(input, function(x) return x % 2 == 0 end)
        print("U.filter({1,2,3,4,5}, even): {" .. table.concat(result, ",") .. "}")
        printTestResult("U.filter", #result == 2 and result[1] == 2 and result[2] == 4, "Filtered correctly")
    end

    DEBUG.logToFile("INFO", "Completed testUtilities()", "debug_log")
end

--[[
    Lighting & Signal Fire Tests (Sequencing & Animation)
]]

--- Initializes all lighting and signal objects to OFF state
-- Sets all signal fires, RING_FLARE, and player lights to OFF instantly
-- Also sets ambient lighting to DARK mode
-- Exposed globally as initLightingAndSignals()
-- @usage initLightingAndSignals() -- Call from TTS console
function DEBUG.initLightingAndSignals()
    print("‚öôÔ∏è  Initializing: Setting all signal fires, hunger smoke, RING_FLARE, player lights to OFF, and ambient to DARK")

    -- NOTE: All object manipulation is done via Objects module
    -- Debug functions should only call other functions, not perform game actions directly

    -- Helper: Convert player color to lighting module light name
    -- Maps "Brown" -> "playerLightBrown", "Orange" -> "playerLightOrange", etc.
    local function getPlayerLightName(color)
        -- Capitalize first letter, lowercase rest
        local first = string.upper(string.sub(color, 1, 1))
        local rest = string.lower(string.sub(color, 2))
        return "playerLight" .. first .. rest
    end

    -- Helper: Set player light mode using lighting module
    -- Uses L.SetLightMode() which handles all properties (position, rotation, range, angle, intensity, enabled)
    local function setPlayerLightMode(color, mode, duration)
        duration = duration or 0.0  -- Default to instant
        local lightName = getPlayerLightName(color)

        if not L or not L.SetLightMode then
            print("‚ö†Ô∏è  Lighting module (L) or SetLightMode not available")
            return false
        end

        if not L.LIGHTMODES[lightName] then
            print("‚ö†Ô∏è  Light mode not found for: " .. lightName)
            return false
        end

        -- Use lighting module to set the mode
        local success, result = pcall(function()
            return L.SetLightMode(lightName, mode, color, duration)
        end)

        if not success then
            print("‚ö†Ô∏è  Error setting player light mode: " .. tostring(result))
            return false
        end

        return true
    end

    local allSuccess = true

    -- Set all signal fires to OFF (instant) - using Objects module
    for _, color in ipairs(C.PlayerColors) do
        local success = O.SetSignalFireState(color, "off", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set all hunger smoke to OFF (instant) - using Objects module
    for _, color in ipairs(C.PlayerColors) do
        local success = O.SetHungerSmokeState(color, "off", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set RING_FLARE to OFF (instant) - using Objects module
    local flareSuccess = O.SetRingFlareState("off", 0.0)  -- 0 = instant
    if not flareSuccess then
        allSuccess = false
    end

    -- Set all player lights to OFF (instant)
    for _, color in ipairs(C.PlayerColors) do
        local success = setPlayerLightMode(color, "OFF", 0.0)  -- 0 = instant
        if not success then
            allSuccess = false
        end
    end

    -- Set ambient lighting to DARK mode (instant)
    if C.LightModes.DARK then
        U.changeLighting(C.LightModes.DARK)
        print("‚úÖ Ambient lighting set to DARK mode")
    else
        print("‚ö†Ô∏è  DARK mode not found in C.LightModes")
        allSuccess = false
    end

    if allSuccess and flareSuccess then
        print("‚úÖ Initialization complete: All objects set to OFF state, ambient lighting set to DARK")
    else
        print("‚ö†Ô∏è  Initialization completed with some errors")
    end
end

--- Helper: Merge partial position with current position
-- Handles partial position updates (e.g., {y=2.5} only changes Y axis)
-- @param obj Object The object to get current position from
-- @param partialPos table Partial position data (e.g., {y=2.5} or {x=1, z=3})
-- @return Vector Complete position with partial values merged
local function mergePosition(obj, partialPos)
    local currentPos = obj.getPosition()
    local newPos = {
        x = partialPos.x or currentPos.x,
        y = partialPos.y or currentPos.y,
        z = partialPos.z or currentPos.z
    }
    return Vector(newPos.x, newPos.y, newPos.z)
end

--- Test lighting and signal fire manipulation with sequencing
-- Tests: Signal fire positioning, lighting changes, U.RunSequence, U.Lerp, broadcasts
function DEBUG.testLightingAndSignals()
    printTestHeader("Lighting & Signal Fire Sequencing Test")
    DEBUG.logToFile("INFO", "Starting testLightingAndSignals()", "debug_log")

    local passed = 0
    local failed = 0

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Wait step with broadcast message
    local function waitStep(message, waitTime)
        waitTime = waitTime or 3.0
        return function()
            broadcast(message, {0.7, 0.7, 0.7})
            return waitTime
        end
    end

    -- NOTE: All object manipulation is done via O module
    -- Debug functions should only call other functions, not perform game actions directly

    -- Helper: Get a random player color for testing
    -- @return string Random player color from C.PlayerColors
    local function getRandomPlayerColor()
        if #C.PlayerColors == 0 then
            return "Brown"  -- Fallback if no colors available
        end
        local randomIndex = math.random(1, #C.PlayerColors)
        return C.PlayerColors[randomIndex]
    end

    -- Helper: Convert player color to lighting module light name
    -- Maps "Brown" -> "playerLightBrown", "Orange" -> "playerLightOrange", etc.
    local function getPlayerLightName(color)
        -- Capitalize first letter, lowercase rest
        local first = string.upper(string.sub(color, 1, 1))
        local rest = string.lower(string.sub(color, 2))
        return "playerLight" .. first .. rest
    end

    -- Helper: Set player light mode using lighting module
    -- Uses L.SetLightMode() which handles all properties (position, rotation, range, angle, intensity, enabled)
    local function setPlayerLightMode(color, mode, duration)
        duration = duration or 0.0  -- Default to instant
        local lightName = getPlayerLightName(color)

        if not L or not L.SetLightMode then
            print("‚ö†Ô∏è  Lighting module (L) or SetLightMode not available")
            return false
        end

        if not L.LIGHTMODES[lightName] then
            print("‚ö†Ô∏è  Light mode not found for: " .. lightName)
            return false
        end

        -- Use lighting module to set the mode
        local success, result = pcall(function()
            return L.SetLightMode(lightName, mode, color, duration)
        end)

        if not success then
            print("‚ö†Ô∏è  Error setting player light mode: " .. tostring(result))
            return false
        end

        return true
    end

    -- Test sequence using U.RunSequence
    local sequenceFunctions = {}

    -- Step 1: Initial broadcast
    table.insert(sequenceFunctions, function()
        broadcast("üî¶ Starting Lighting & Signal Fire Test", {1, 1, 0.5})
        return 2.0
    end)

    -- Step 2: INITIALIZATION - Use the extracted initialization function
    table.insert(sequenceFunctions, function()
        broadcast("‚öôÔ∏è  Initializing: Setting all signal fires, RING_FLARE, player lights to OFF, and ambient to DARK", {0.8, 0.8, 1})

        -- Call the extracted initialization function
        DEBUG.initLightingAndSignals()

        printTestResult("Initialization", true, "All objects set to OFF state, ambient set to DARK")
        passed = passed + 1

        return 1.0  -- Brief pause after initialization
    end)

    -- Step 3: Wait after initialization
    table.insert(sequenceFunctions, waitStep("Initialization complete, waiting 3 seconds...", 3.0))

    -- Step 4: Test signal fire ON (random player)
    local randomSignalFireColor = getRandomPlayerColor()
    table.insert(sequenceFunctions, function()
        broadcast("üî• Testing Signal Fire ON (" .. randomSignalFireColor .. " player)", {1, 0.5, 0})
        local success = O.SetSignalFireState(randomSignalFireColor, "on", 0)  -- 0.2 seconds (3x faster)
        if success then
            printTestResult("Signal Fire ON (" .. randomSignalFireColor .. ")", true, "Fire moved to y=1.5")
            passed = passed + 1
        else
            printTestResult("Signal Fire ON (" .. randomSignalFireColor .. ")", false, "Failed to move fire")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 5: Wait after signal fire ON
    table.insert(sequenceFunctions, waitStep("Signal Fire finished raising, waiting 3 seconds...", 3.0))

    -- Step 6: Test signal fire OFF (random player)
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Testing Signal Fire OFF (" .. randomSignalFireColor .. " player)", {0.5, 0.5, 0.5})
        local success = O.SetSignalFireState(randomSignalFireColor, "off", 0)  -- 0 seconds (instant)
        if success then
            printTestResult("Signal Fire OFF (" .. randomSignalFireColor .. ")", true, "Fire moved to y=-7")
            passed = passed + 1
        else
            printTestResult("Signal Fire OFF (" .. randomSignalFireColor .. ")", false, "Failed to move fire")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 7: Wait after signal fire OFF
    table.insert(sequenceFunctions, waitStep("Signal Fire finished lowering, waiting 3 seconds...", 3.0))

    -- Step 8: Test multiple signal fires ON (all player colors)
    table.insert(sequenceFunctions, function()
        broadcast("üî• Testing All Signal Fires ON", {1, 0.5, 0})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetSignalFireState(color, "on", 0)  -- 0 seconds (instant)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Signal Fires ON", true, "All " .. #C.PlayerColors .. " fires activated")
            passed = passed + 1
        else
            printTestResult("All Signal Fires ON", false, "Some fires failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 9: Wait after all signal fires ON
    table.insert(sequenceFunctions, waitStep("All Signal Fires finished raising, waiting 3 seconds...", 3.0))

    -- Step 10: Lerp each player light from OFF to STANDARD (one after another)
    table.insert(sequenceFunctions, function()
        broadcast("üí° Testing Player Lights: OFF ‚Üí STANDARD (sequential)", {1, 1, 0.5})
        local allSuccess = true
        local lerpDuration = 2.0

        -- Create sequence for each player light
        local lightSequence = {}
        for _, color in ipairs(C.PlayerColors) do
            table.insert(lightSequence, function()
                broadcast("  ‚Üí " .. color .. " light transitioning...", {0.8, 0.8, 1})
                local success = setPlayerLightMode(color, "STANDARD", lerpDuration)
                if not success then
                    allSuccess = false
                end
                return lerpDuration + 0.5  -- Wait for animation + brief pause
            end)
        end

        -- Run the sequence of light transitions
        U.RunSequence(lightSequence)

        if allSuccess then
            printTestResult("Player Lights OFF‚ÜíSTANDARD", true, "All " .. #C.PlayerColors .. " lights transitioned")
            passed = passed + 1
        else
            printTestResult("Player Lights OFF‚ÜíSTANDARD", false, "Some lights failed")
            failed = failed + 1
        end

        -- Return total time for all lights (approximate)
        return (lerpDuration + 0.5) * #C.PlayerColors
    end)

    -- Step 11: Wait after player lights transition
    table.insert(sequenceFunctions, waitStep("All Player Lights finished transitioning, waiting 3 seconds...", 3.0))

    -- Step 12: Instantly switch RING_FLARE to ON
    table.insert(sequenceFunctions, function()
        broadcast("‚ú® Testing RING_FLARE: Switching to ON (instant)", {1, 1, 0})
        local success = O.SetRingFlareState("on", 0.0)  -- 0 = instant
        if success then
            printTestResult("RING_FLARE ON", true, "RING_FLARE moved to y=-0.08")
            passed = passed + 1
        else
            printTestResult("RING_FLARE ON", false, "Failed to move RING_FLARE")
            failed = failed + 1
        end
        return 2.0  -- Brief pause to observe
    end)

    -- Step 13: Wait after RING_FLARE ON
    table.insert(sequenceFunctions, waitStep("RING_FLARE switched ON, waiting 3 seconds...", 3.0))

    -- Step 14: Instantly switch RING_FLARE to OFF
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Testing RING_FLARE: Switching to OFF (instant)", {0.5, 0.5, 0.5})
        local success = O.SetRingFlareState("off", 0.0)  -- 0 = instant
        if success then
            printTestResult("RING_FLARE OFF", true, "RING_FLARE moved to y=-60")
            passed = passed + 1
        else
            printTestResult("RING_FLARE OFF", false, "Failed to move RING_FLARE")
            failed = failed + 1
        end
        return 2.0  -- Brief pause to observe
    end)

    -- Step 15: Wait after RING_FLARE OFF
    table.insert(sequenceFunctions, waitStep("RING_FLARE switched OFF, waiting 3 seconds...", 3.0))

    -- Step 19: Test hunger smoke ON (Brown player)
    local randomHungerSmokeColor = getRandomPlayerColor()
    table.insert(sequenceFunctions, function()
        broadcast("üí® Testing Hunger Smoke ON (" .. randomHungerSmokeColor .. " player)", {0.8, 0.4, 0.8})
        local success = O.SetHungerSmokeState(randomHungerSmokeColor, "on", 0)  -- 0 seconds (instant)
        if success then
            printTestResult("Hunger Smoke ON (" .. randomHungerSmokeColor .. ")", true, "Smoke moved to y=0.2")
            passed = passed + 1
        else
            printTestResult("Hunger Smoke ON (" .. randomHungerSmokeColor .. ")", false, "Failed to move smoke")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 20: Wait after hunger smoke ON
    table.insert(sequenceFunctions, waitStep("Hunger Smoke finished raising, waiting 3 seconds...", 3.0))

    -- Step 21: Test hunger smoke OFF (random player)
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Testing Hunger Smoke OFF (" .. randomHungerSmokeColor .. " player)", {0.5, 0.5, 0.5})
        local success = O.SetHungerSmokeState(randomHungerSmokeColor, "off", 0)  -- 0 seconds (instant)
        if success then
            printTestResult("Hunger Smoke OFF (" .. randomHungerSmokeColor .. ")", true, "Smoke moved to y=-7")
            passed = passed + 1
        else
            printTestResult("Hunger Smoke OFF (" .. randomHungerSmokeColor .. ")", false, "Failed to move smoke")
            failed = failed + 1
        end
        return 1.5  -- Wait for animation
    end)

    -- Step 22: Wait after hunger smoke OFF
    table.insert(sequenceFunctions, waitStep("Hunger Smoke finished lowering, waiting 3 seconds...", 3.0))

    -- Step 23: Test all hunger smoke ON (all player colors)
    table.insert(sequenceFunctions, function()
        broadcast("üí® Testing All Hunger Smoke ON", {0.8, 0.4, 0.8})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetHungerSmokeState(color, "on", 0)  -- 0 seconds (instant)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Hunger Smoke ON", true, "All " .. #C.PlayerColors .. " smoke activated")
            passed = passed + 1
        else
            printTestResult("All Hunger Smoke ON", false, "Some smoke failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)

    -- Step 24: Wait after all hunger smoke ON
    table.insert(sequenceFunctions, waitStep("All Hunger Smoke finished raising, waiting 3 seconds...", 3.0))

    -- Step 25: Turn off all hunger smoke
    table.insert(sequenceFunctions, function()
        broadcast("üí§ Turning Off All Hunger Smoke", {0.5, 0.5, 0.5})
        local allSuccess = true
        for _, color in ipairs(C.PlayerColors) do
            local success = O.SetHungerSmokeState(color, "off", 0)  -- 0 seconds (instant)
            if not success then
                allSuccess = false
            end
        end
        if allSuccess then
            printTestResult("All Hunger Smoke OFF", true, "All smoke deactivated")
            passed = passed + 1
        else
            printTestResult("All Hunger Smoke OFF", false, "Some smoke failed")
            failed = failed + 1
        end
        return 2.0  -- Wait for animations
    end)


    -- Step 24: Wait after all hunger smoke OFF
    table.insert(sequenceFunctions, waitStep("All Hunger Smoke finished lowering, waiting 3 seconds...", 3.0))

    -- Step 16: Simultaneously lerp all player lights from STANDARD to OFF
    table.insert(sequenceFunctions, function()
      broadcast("üí§ Testing Player Lights: STANDARD ‚Üí OFF (simultaneous)", {0.5, 0.5, 0.5})
      local allSuccess = true
      local lerpDuration = 2.0

      -- Start all transitions simultaneously
      for _, color in ipairs(C.PlayerColors) do
          local success = setPlayerLightMode(color, "OFF", lerpDuration)
          if not success then
              allSuccess = false
          end
      end

      if allSuccess then
          printTestResult("Player Lights STANDARD‚ÜíOFF", true, "All " .. #C.PlayerColors .. " lights transitioned simultaneously")
          passed = passed + 1
      else
          printTestResult("Player Lights STANDARD‚ÜíOFF", false, "Some lights failed")
          failed = failed + 1
      end

      return lerpDuration + 1.0  -- Wait for animation to complete
  end)

  -- Step 17: Wait after simultaneous player lights OFF
  table.insert(sequenceFunctions, waitStep("All Player Lights finished transitioning to OFF, waiting 3 seconds...", 3.0))

  -- Step 18: Turn off all signal fires
  table.insert(sequenceFunctions, function()
      broadcast("üí§ Turning Off All Signal Fires", {0.5, 0.5, 0.5})
      local allSuccess = true
      for _, color in ipairs(C.PlayerColors) do
          local success = O.SetSignalFireState(color, "off", 0.2)  -- 0.2 seconds (3x faster)
          if not success then
              allSuccess = false
          end
      end
      if allSuccess then
          printTestResult("All Signal Fires OFF", true, "All fires deactivated")
          passed = passed + 1
      else
          printTestResult("All Signal Fires OFF", false, "Some fires failed")
          failed = failed + 1
      end
      return 2.0  -- Wait for animations
  end)

    -- Step 19: Final summary
    table.insert(sequenceFunctions, function()
        broadcast("‚úÖ Lighting & Signal Fire Test Complete!", {0, 1, 0})
        print("\n" .. string.rep("-", 60))
        print("Lighting & Signal Fire Tests: " .. passed .. " passed, " .. failed .. " failed")
        print(string.rep("-", 60))

        local summary = string.format("Lighting & Signal Fire Tests: %d passed, %d failed", passed, failed)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("Lighting & Signal Fire Sequencing", failed == 0, summary, "test_results")
        return 0  -- No wait needed
    end)

    -- Execute the sequence
    print("Starting sequence test with " .. #sequenceFunctions .. " steps...")
    print("This will take approximately 2-3 minutes to complete.")
    print("Watch for broadcast messages and visual changes.\n")

    -- Use U.RunSequence to execute all steps
    U.RunSequence(sequenceFunctions)
end

--[[
    Light Creation Feasibility Tests

    These functions test the feasibility of creating custom point-source lights
    programmatically instead of using third-party configurable lights.

    See dev/LIGHT_CREATION_FEASIBILITY.md for detailed investigation.
]]

--- Test if "Light" is a spawnable built-in type
-- @usage testSpawnLightType()
function DEBUG.testSpawnLightType()
    return LightTest.testSpawnLightType()
end

--- Test cloning an existing light object
-- @param templateGUID string GUID of light object to clone
-- @usage testCloneLight("abc123")
function DEBUG.testCloneLight(templateGUID)
    return LightTest.testCloneLight(templateGUID)
end

--- Inspect Light component properties
-- @param lightGUID string GUID of light object to inspect
-- @usage testInspectLight("abc123")
function DEBUG.testInspectLight(lightGUID)
    return LightTest.testInspectLight(lightGUID)
end

--- Test spawning a light from a template
-- @param templateGUID string GUID of light template
-- @param position Vector Position to spawn light (optional)
-- @param rotation Vector Rotation of light (optional)
-- @param config table Light configuration {enabled, range, intensity, color, angle} (optional)
-- @usage testSpawnLight("abc123", Vector(0,5,0), Vector(0,0,0), {range=50, intensity=15})
function DEBUG.testSpawnLight(templateGUID, position, rotation, config)
    return LightTest.testSpawnLight(templateGUID, position, rotation, config)
end

--- Compare current light structure with potential new structure
-- @param currentLightGUID string GUID of current configurable light
-- @usage testCompareStructures("abc123")
function DEBUG.testCompareStructures(currentLightGUID)
    return LightTest.testCompareStructures(currentLightGUID)
end

--- Find all objects that might be lights
-- @usage findPotentialLights()
function DEBUG.findPotentialLights()
    return LightTest.findPotentialLights()
end

--- Test easing and path generation functions
-- Tests U.GetEasedValue, U.GetEasedPath, and enhanced U.Lerp with various scenarios
--
-- Required objects in scene (by GUID):
--   - TEST_OBJ_1: Object to lerp (position/rotation tests)
--   - TEST_OBJ_2: Object to lerp (parallel tests)
--   - TEST_CENTER_OBJ: Object to use as center for orbital paths
--   - TEST_TARGET_OBJ: Object to face/look at
-- Global state for interactive test continuation
local testWaitingForContinue = false

-- Global function to continue to next test step (callable from console)
--- Minimal test function to test just the look-at rotation
-- Orients TEST_LIGHT to face TEST_TARGET_OBJ immediately
-- Uses the same GUIDs as testEasing() for consistency
-- @usage testLookAt()
function testLookAt()
	-- Local broadcast function for this test
	local function broadcast(message, color)
		if color == nil then color = {1, 1, 1} end
		broadcastToAll(message, color)
	end
	-- Use the same GUIDs as testEasing
	local TEST_LIGHT_GUID = "6e3ee4"  -- Same as TEST_LIGHT in testEasing
	local TEST_TARGET_GUID = "199e6f"  -- Same as TEST_TARGET_OBJ in testEasing

	local lightObj = getObjectFromGUID(TEST_LIGHT_GUID)
	local targetObj = getObjectFromGUID(TEST_TARGET_GUID)

	if not lightObj then
		print("ERROR: testLookAt - TEST_LIGHT not found (GUID: " .. TEST_LIGHT_GUID .. ")")
		broadcast("‚ùå testLookAt: Light object not found", {1, 0, 0})
		return
	end

	if not targetObj then
		print("ERROR: testLookAt - TEST_TARGET_OBJ not found (GUID: " .. TEST_TARGET_GUID .. ")")
		broadcast("‚ùå testLookAt: Target object not found", {1, 0, 0})
		return
	end

	print("testLookAt: Getting positions...")
	local success1, lightPos = pcall(function() return lightObj.getPosition() end)
	local success2, targetPos = pcall(function() return targetObj.getPosition() end)

	if not success1 then
		print("ERROR: testLookAt - Failed to get light position: " .. tostring(lightPos))
		broadcast("‚ùå testLookAt: Failed to get light position", {1, 0, 0})
		return
	end

	if not success2 then
		print("ERROR: testLookAt - Failed to get target position: " .. tostring(targetPos))
		broadcast("‚ùå testLookAt: Failed to get target position", {1, 0, 0})
		return
	end

	if not lightPos then
		print("ERROR: testLookAt - Light position is nil")
		broadcast("‚ùå testLookAt: Light position is nil", {1, 0, 0})
		return
	end

	if not targetPos then
		print("ERROR: testLookAt - Target position is nil")
		broadcast("‚ùå testLookAt: Target position is nil", {1, 0, 0})
		return
	end

	-- Validate positions are Vector-like (have x, y, z properties)
	if not (lightPos and (type(lightPos.x) == "number" or lightPos.getX ~= nil)) then
		print("ERROR: testLookAt - Light position is not a valid Vector")
		broadcast("‚ùå testLookAt: Light position is not a Vector", {1, 0, 0})
		return
	end

	if not (targetPos and (type(targetPos.x) == "number" or targetPos.getX ~= nil)) then
		print("ERROR: testLookAt - Target position is not a valid Vector")
		broadcast("‚ùå testLookAt: Target position is not a Vector", {1, 0, 0})
		return
	end

	-- Calculate rotation
	local success3, rotation = pcall(function() return U.lookAtRotation(lightPos, targetPos) end)

	if not success3 or not rotation then
		print("ERROR: testLookAt - U.lookAtRotation failed: " .. tostring(rotation))
		broadcast("‚ùå testLookAt: Rotation calculation failed", {1, 0, 0})
		return
	end
	local success, err = pcall(function()
		lightObj.setRotationSmooth(rotation, false, false)
	end)

	if not success then
		print("ERROR: testLookAt - Failed to set rotation: " .. tostring(err))
		broadcast("‚ùå testLookAt: Failed to set rotation", {1, 0, 0})
		return
	end

	print("testLookAt: SUCCESS - Rotation set to: " .. tostring(rotation))
	broadcast("‚úÖ testLookAt: Rotation applied successfully", {0, 1, 0})
end

-- Usage: continueTest()
function continueTest()
	if testWaitingForContinue then
		testWaitingForContinue = false  -- Signal to continue
		print("‚úÖ Continuing to next step...")
		broadcastToAll("‚ñ∂Ô∏è Test continuing...", {0, 1, 0})
		return true
	else
		print("‚ÑπÔ∏è No test currently waiting for continuation")
		return false
	end
end

function DEBUG.testEasing()
	printTestHeader("Easing and Path Generation")

	-- Helper: Broadcast message to all players
	local function broadcast(message, color)
		color = color or {1, 1, 1}  -- Default white
		broadcastToAll(message, color)
		print("üì¢ " .. message)
	end

	-- Helper: Pause until continueTest() is called
	local function pauseStep(message)
		return function()
			broadcast(message, {0.8, 0.8, 1})
			print("üí° To continue, type in console: continueTest()")
			testWaitingForContinue = true
			return function() return testWaitingForContinue == false end
		end
	end

	broadcast("üé¨ Starting Easing and Path Generation Tests", {0.8, 0.8, 1})

  -- Test configuration constants
	local TEST_GUIDS = {
		TEST_LIGHT = "6e3ee4",  -- Replace with actual GUID for test object 1
		TEST_BLOCK = "432c34",  -- Replace with actual GUID for test object 2
		TEST_CENTER_OBJ = "9c3b86",  -- Replace with actual GUID for center object
		TEST_TARGET_OBJ = "199e6f"   -- Replace with actual GUID for target object
	}


	local TEST_PARAMETERS = {
		ORBITING_LIGHT = {
			-- The "Orbiting Light" test should lerp `TEST_LIGHT` so that it orbits around `TEST_TARGET_OBJ` using spherical coordinates
			-- Note: Use CURRENT radius but explicit angle/angle2 to control the start direction.
			-- Optional: parallelLerps can run extra U.Lerp() calls alongside the position/orientation lerp.
			start = {
				position = {radius = "CURRENT", angle = 0, angle2 = -20},  -- Use current radius, explicit angles
				center = "TEST_TARGET_OBJ",  -- Will be resolved to targetObj
				orientation = "TEST_TARGET_OBJ"  -- Will be resolved to targetObj (face target)
			},
			-- End: same radius, angle +800¬∞ (multi-revolution), angle2 from -20¬∞ to 20¬∞
			endVal = {
				position = {radius = {mult = 2}, angle = "+800", angle2 = 20},  -- Radius doubles, angle relative, angle2 absolute
				center = "TEST_TARGET_OBJ",
				orientation = "TEST_TARGET_OBJ"  -- Continue facing target
			},
			duration = 10.0,
			ease = "sineInOut",
			easeIntensity = 1.0,
			coordinateSystem = "spherical",
			objectToMove = "TEST_LIGHT",  -- Which object to animate
			parallelLerps = {
				{
					target = "TEST_LIGHT",
					setFunc = function(val, obj) L.SetColor(obj, val) end,
					start = Color(1, 1, 1),
					endVal = Color(1, 0, 0)
				},
				{
					target = "TEST_LIGHT",
					setFunc = function(val, obj) L.SetAngle(obj, val) end,
					getStart = function(obj) return L.GetAngle(obj) end,
					getEnd = function(obj) return L.GetAngle(obj) * 0.1 end
				},
				{
					target = "TEST_LIGHT",
					setFunc = function(val, obj) L.SetIntensity(obj, val) end,
					getStart = function(obj) return L.GetIntensity(obj) end,
					getEnd = function(obj) return L.GetIntensity(obj) * 2 end
				}
			}
		},
		CYLINDRICAL_SPIRAL = {
			-- The "Cylindrical Spiral" test should use cylindrical coordinates to lerp "TEST_LIGHT" from its current position to radius=0 units away from `TEST_CENTER_OBJ`, maintaining its height as it does so, and making two full revolutions around TEST_CENTER_OBJ, so that it "spirals in" to TEST_CENTER_OBJ.  Its orientation should always be downward (i.e. X=0, Y=90, Z=0)
			-- Note: position="CURRENT" means use the object's current position at test time
			start = {
				position = "CURRENT",  -- Will be resolved to light's current position in cylindrical coords
				center = "TEST_CENTER_OBJ",  -- Will be resolved to centerObj
				orientation = Vector(0, 90, 0)  -- Downward
			},
			-- End: radius=0 (at center), same height, angle + 720¬∞ (2 full revolutions)
			endVal = {
				position = {radius = 0, angle = "+720", height = "SAME"},  -- Relative to start
				center = "TEST_CENTER_OBJ",
				orientation = Vector(0, 90, 0)  -- Continue downward
			},
			duration = 10.0,
			ease = "sineInOut",
			easeIntensity = 1.0,
			coordinateSystem = "cylindrical",
			objectToMove = "TEST_LIGHT"  -- Which object to animate
		}
	}



	local TEST_DURATION = 10.0  -- 2 seconds per test

	-- Helper: Get object by GUID or fail
	local function getTestObject(guid, name)
		local obj = getObjectFromGUID(guid)
		if obj == nil then
			printTestResult(name, false, "Missing object with GUID: " .. guid)
			return nil
		end
		return obj
	end

	-- Helper: Resolve TEST_PARAMETERS into actual PositionOrientationData
	-- Handles special values like "CURRENT", "SAME", "+360", object name strings, etc.
	-- @param paramData table PositionOrientationData from TEST_PARAMETERS (may contain special values)
	-- @param objects table Map of object names to actual objects (e.g., {TEST_LIGHT = obj, ...})
	-- @param startData table|nil Resolved start data (for relative values like "SAME", "+360")
	-- @param coordinateSystem string Coordinate system being used
	-- @param objectToMove string|nil Name of object to move (for "CURRENT" position resolution)
	-- @return table Resolved PositionOrientationData
	local function resolveTestData(paramData, objects, startData, coordinateSystem, objectToMove)

		local resolved = {}

		-- Helper: Resolve CURRENT coordinate values (per-field) for cylindrical/spherical
		local function getCurrentCoord()
			local objToMoveRef = objects[objectToMove or "TEST_LIGHT"]
			if not objToMoveRef then
				U.error("resolveTestData", "CURRENT field requires objectToMove to be set")
				return nil
			end
			local currentPos = objToMoveRef.getPosition()
			local centerVal = paramData.center
			if centerVal ~= nil then
				if U.Type(centerVal) == "string" and objects[centerVal] then
					centerVal = objects[centerVal]
				end
				if not U.isGameObject(centerVal) then
					centerVal = Vector(centerVal)
				end
			else
				centerVal = Vector(0, 0, 0)
			end
			if coordinateSystem == "cylindrical" then
				return U.XYZToCylindrical(currentPos, centerVal)
			elseif coordinateSystem == "spherical" then
				return U.XYZToSpherical(currentPos, centerVal)
			end
			return nil
		end

		-- Resolve position
		if paramData.position ~= nil then
			if paramData.position == "CURRENT" then
				-- Use object's current position (will be converted to coordinate system if needed)
				local objToMoveRef = objects[objectToMove or "TEST_LIGHT"]
				if objToMoveRef then
					local currentPos = objToMoveRef.getPosition()
					local center = resolveTestData({center = paramData.center}, objects, nil, coordinateSystem, objectToMove).center
					-- Convert center to Vector only if not an Object (Object preserves yaw)
					if not U.isGameObject(center) then
						center = Vector(center)
					end
					if coordinateSystem == "cylindrical" then
						resolved.position = U.XYZToCylindrical(currentPos, center)
					elseif coordinateSystem == "spherical" then
						resolved.position = U.XYZToSpherical(currentPos, center)
						-- Override angle to start at 0 if specified in paramData
						if paramData.overrideAngle ~= nil then
							resolved.position.angle = paramData.overrideAngle
						end
						-- Override angle2 if specified in paramData
						if paramData.overrideAngle2 ~= nil then
							resolved.position.angle2 = paramData.overrideAngle2
						end
					else
						resolved.position = currentPos
					end
				else
					U.error("resolveTestData", "CURRENT position requires objectToMove to be set")
				end
			elseif U.Type(paramData.position) == "table" and paramData.position.radius ~= nil then
				-- Check if this is spherical or cylindrical coordinates
				if paramData.position.angle2 ~= nil then
					-- Spherical coordinates with relative values
					local sph = {}
					local currentCoord = nil
					if paramData.position.radius == "SAME" and startData then
						sph.radius = startData.position.radius
					elseif U.Type(paramData.position.radius) == "table" and paramData.position.radius.mult and startData then
						sph.radius = startData.position.radius * paramData.position.radius.mult
					elseif paramData.position.radius == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						sph.radius = currentCoord and currentCoord.radius
					else
						sph.radius = paramData.position.radius
					end
					if paramData.position.angle == "SAME" and startData then
						sph.angle = startData.position.angle
					elseif paramData.position.angle == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						sph.angle = currentCoord and currentCoord.angle
					elseif U.Type(paramData.position.angle) == "string" then
						-- Relative angle (e.g., "+360", "-90")
						local sign = paramData.position.angle:sub(1, 1)
						local offset = tonumber(paramData.position.angle:sub(2))
						if (sign == "+" or sign == "-") and offset ~= nil then
							local delta = offset * (sign == "-" and -1 or 1)
							sph.angle = (startData and startData.position.angle or 0) + delta
						else
							U.error("resolveTestData", "Invalid angle string; expected '+X' or '-X'", paramData.position.angle)
						end
					else
						sph.angle = paramData.position.angle
					end
					if paramData.position.angle2 == "SAME" and startData then
						sph.angle2 = startData.position.angle2
					elseif paramData.position.angle2 == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						sph.angle2 = currentCoord and currentCoord.angle2
					else
						sph.angle2 = paramData.position.angle2
					end
					sph.angleMode = paramData.position.angleMode
					resolved.position = sph
				else
					-- Cylindrical coordinates with relative values
					local cyl = {}
					local currentCoord = nil
					if paramData.position.radius == "SAME" and startData then
						cyl.radius = startData.position.radius
					elseif U.Type(paramData.position.radius) == "table" and paramData.position.radius.mult and startData then
						cyl.radius = startData.position.radius * paramData.position.radius.mult
					elseif paramData.position.radius == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						cyl.radius = currentCoord and currentCoord.radius
					else
						cyl.radius = paramData.position.radius
					end
					if paramData.position.angle == "SAME" and startData then
						cyl.angle = startData.position.angle
					elseif paramData.position.angle == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						cyl.angle = currentCoord and currentCoord.angle
					elseif U.Type(paramData.position.angle) == "string" then
						-- Relative angle (e.g., "+360", "-90")
						local sign = paramData.position.angle:sub(1, 1)
						local offset = tonumber(paramData.position.angle:sub(2))
						if (sign == "+" or sign == "-") and offset ~= nil then
							local delta = offset * (sign == "-" and -1 or 1)
							cyl.angle = (startData and startData.position.angle or 0) + delta
						else
							U.error("resolveTestData", "Invalid angle string; expected '+X' or '-X'", paramData.position.angle)
						end
					else
						cyl.angle = paramData.position.angle
					end
					if paramData.position.height == "SAME" and startData then
						cyl.height = startData.position.height
					elseif paramData.position.height == "CURRENT" then
						currentCoord = currentCoord or getCurrentCoord()
						cyl.height = currentCoord and currentCoord.height
					else
						cyl.height = paramData.position.height
					end
					cyl.angleMode = paramData.position.angleMode
					resolved.position = cyl
				end
			else
				-- Direct value (Vector, table, etc.)
				resolved.position = paramData.position
			end
		end

		-- Resolve center
		if paramData.center ~= nil then
			if U.Type(paramData.center) == "string" and objects[paramData.center] then
				resolved.center = objects[paramData.center]
			else
				resolved.center = paramData.center
			end
		end

		-- Resolve orientation
		if paramData.orientation ~= nil then
			if U.Type(paramData.orientation) == "string" and objects[paramData.orientation] then
				resolved.orientation = objects[paramData.orientation]
			else
				resolved.orientation = paramData.orientation
			end
		end

		return resolved
	end

	-- Helper: Build and run parallel lerps from test definitions
	-- parallelLerps entries support:
	--   - target: object name in testObjects (optional, defaults to objectToMove)
	--   - setFunc: function(value, targetObj) to apply values (required if no setter)
	--   - setter: string method name to call on target (e.g., "setColorTint")
	--   - getStart: function(targetObj) -> value (optional)
	--   - getEnd: function(targetObj) -> value (optional)
	--   - start / endVal: explicit values (numbers, Vectors, Colors)
	--   - duration / easing / isRotationLerp: override defaults (optional)
	local function runParallelLerps(lerps, objects, objToMove, defaultDuration, defaultEase)
		if not lerps or #lerps == 0 then return 0 end
		local maxDuration = 0
		for _, lerpDef in ipairs(lerps) do
			local targetObj = objToMove
			if lerpDef.target ~= nil then
				targetObj = objects[lerpDef.target] or lerpDef.target
			end

			local setFunc = lerpDef.setFunc
			if setFunc == nil and lerpDef.setter ~= nil and targetObj ~= nil then
				local method = targetObj[lerpDef.setter]
				if U.Type(method) == "function" then
					setFunc = function(val) method(targetObj, val) end
				end
			end
			U.Val("runParallelLerps", setFunc, U.Type(setFunc) == "function", "Parallel lerp requires setFunc or valid setter")

			local startVal = lerpDef.start
			if lerpDef.getStart ~= nil then
				startVal = lerpDef.getStart(targetObj)
			end
			local endVal = lerpDef.endVal
			if lerpDef.getEnd ~= nil then
				endVal = lerpDef.getEnd(targetObj)
			end

			local lerpDuration = lerpDef.duration or defaultDuration
			local lerpEasing = lerpDef.easing or defaultEase
			local isRotationLerp = lerpDef.isRotationLerp or false

			local duration = U.Lerp(setFunc, startVal, endVal, lerpDuration, isRotationLerp, lerpEasing)
			if duration and duration > maxDuration then
				maxDuration = duration
			end
		end
		return maxDuration
	end

	-- Test 1: U.GetEasedValue (simple number interpolation)
	broadcast("Test 1: GetEasedValue (Number)", {0.7, 0.7, 0.7})
	print("\n--- Test 1: U.GetEasedValue (Number) ---")
	local numberPath = U.GetEasedValue(0.0, 1.0, 1.0, "sineInOut", 1.0)
	if numberPath and #numberPath > 0 then
		printTestResult("GetEasedValue (Number)", true, "Generated " .. #numberPath .. " values")
		broadcast("‚úÖ Test 1 Passed: Generated " .. #numberPath .. " values", {0, 1, 0})
	else
		printTestResult("GetEasedValue (Number)", false, "Failed to generate path")
		broadcast("‚ùå Test 1 Failed: Path generation failed", {1, 0, 0})
	end

	-- Test 2: U.GetEasedValue (Color interpolation)
	broadcast("Test 2: GetEasedValue (Color)", {0.7, 0.7, 0.7})
	print("\n--- Test 2: U.GetEasedValue (Color) ---")
	local colorPath = U.GetEasedValue(Color(1, 0, 0), Color(0, 0, 1), 1.0, "sineInOut", 1.0)
	if colorPath and #colorPath > 0 then
		printTestResult("GetEasedValue (Color)", true, "Generated " .. #colorPath .. " values")
		broadcast("‚úÖ Test 2 Passed: Generated " .. #colorPath .. " color values", {0, 1, 0})
	else
		printTestResult("GetEasedValue (Color)", false, "Failed to generate path")
		broadcast("‚ùå Test 2 Failed: Path generation failed", {1, 0, 0})
	end

	-- Test 3: Spherical Coordinate Transformation Validation
	broadcast("Test 3: Spherical Coordinate Transformation", {0.7, 0.7, 0.7})
	print("\n--- Test 3: Spherical Coordinate Transformation Validation ---")

	-- Generate a 4-frame path: full 360¬∞ rotation at radius 15, horizontal plane (angle2=0¬∞)
	-- Expected positions: {0,0,15}, {15,0,0}, {0,0,-15}, {-15,0,0} (XZ plane circle)
	local center = Vector(0, 0, 0)
	local startSpherical = {radius = 15, angle = 0, angle2 = 0}   -- Horizontal plane, starting at +Z
	local endSpherical = {radius = 15, angle = 360, angle2 = 0}   -- Full rotation, same elevation

	local sphericalPath = U.GetEasedPath(
		{position = startSpherical, center = center},
		{position = endSpherical, center = center},
		1.0,  -- 1 second duration
		"linear",
		1.0,
		"spherical"
	)

	local testPassed = false
	local errorMessage = ""

	if sphericalPath and sphericalPath ~= "DEFER" and #sphericalPath >= 61 then
		-- Expected positions at key angles (0¬∞, 90¬∞, 180¬∞, 270¬∞)
		-- In TTS: angle 0¬∞ = +Z, 90¬∞ = +X, 180¬∞ = -Z, 270¬∞ = -X
		-- With 61 frames (0-60), we check frames at t=0, 0.25, 0.5, 0.75
		local frameIndices = {1, 16, 31, 46}  -- Frames 0, 15, 30, 45 (1-indexed: 1, 16, 31, 46)
		local expectedPositions = {
			Vector(0, 0, 15),    -- angle = 0¬∞ (frame 0, t=0)
			Vector(15, 0, 0),     -- angle = 90¬∞ (frame 15, t=0.25)
			Vector(0, 0, -15),    -- angle = 180¬∞ (frame 30, t=0.5)
			Vector(-15, 0, 0)     -- angle = 270¬∞ (frame 45, t=0.75)
		}

		local allMatch = true
		local mismatches = {}

		for i = 1, #frameIndices do
			local frameIdx = frameIndices[i]
			if frameIdx > #sphericalPath then
				allMatch = false
				table.insert(mismatches, "Frame " .. (frameIdx - 1) .. ": Path too short")
			else
				local actualPos = sphericalPath[frameIdx].position
				local expectedPos = expectedPositions[i]

				if actualPos then
					-- Allow small floating point differences (0.01 tolerance)
					local tolerance = 0.01
					local dx = math.abs(actualPos.x - expectedPos.x)
					local dy = math.abs(actualPos.y - expectedPos.y)
					local dz = math.abs(actualPos.z - expectedPos.z)

					if dx > tolerance or dy > tolerance or dz > tolerance then
						allMatch = false
						table.insert(mismatches, string.format(
							"Frame %d (angle ~%d¬∞): Expected %s, got %s (diff: %.3f, %.3f, %.3f)",
							frameIdx - 1, (i - 1) * 90, tostring(expectedPos), tostring(actualPos), dx, dy, dz
						))
					end
				else
					allMatch = false
					table.insert(mismatches, "Frame " .. (frameIdx - 1) .. ": Missing position")
				end
			end
		end

		if allMatch then
			testPassed = true
			printTestResult("Spherical Coordinate Transformation", true, "All key positions (0¬∞, 90¬∞, 180¬∞, 270¬∞) match expected values")
			broadcast("‚úÖ Test 3 Passed: Spherical coordinates transform correctly", {0, 1, 0})
		else
			errorMessage = "Position mismatches:\n  " .. table.concat(mismatches, "\n  ")
			printTestResult("Spherical Coordinate Transformation", false, errorMessage)
			broadcast("‚ùå Test 3 Failed: Position mismatches detected", {1, 0, 0})
		end
	else
		errorMessage = "Failed to generate path or path has fewer than 61 frames"
		if sphericalPath == "DEFER" then
			errorMessage = "Path generation was deferred (unexpected for static coordinates)"
		elseif sphericalPath and #sphericalPath > 0 then
			errorMessage = "Path has only " .. #sphericalPath .. " frames, expected 61"
		end
		printTestResult("Spherical Coordinate Transformation", false, errorMessage)
		broadcast("‚ùå Test 3 Failed: " .. errorMessage, {1, 0, 0})
	end

	-- Test 4: Cylindrical Coordinate Transformation Validation
	broadcast("Test 4: Cylindrical Coordinate Transformation", {0.7, 0.7, 0.7})
	print("\n--- Test 4: Cylindrical Coordinate Transformation Validation ---")

	-- Generate a 4-frame path: full 360¬∞ rotation at radius 15, height 0
	-- Expected positions: {0,0,15}, {15,0,0}, {0,0,-15}, {-15,0,0} (XZ plane circle)
	local startCylindrical = {radius = 15, angle = 0, height = 0}
	local endCylindrical = {radius = 15, angle = 360, height = 0}

	local cylindricalPath = U.GetEasedPath(
		{position = startCylindrical, center = center},
		{position = endCylindrical, center = center},
		1.0,  -- 1 second duration
		"linear",
		1.0,
		"cylindrical"
	)

	local test4Passed = false
	local errorMessage4 = ""

	if cylindricalPath and cylindricalPath ~= "DEFER" and #cylindricalPath >= 61 then
		-- Expected positions at key angles (0¬∞, 90¬∞, 180¬∞, 270¬∞)
		-- With 61 frames (0-60), we check frames at t=0, 0.25, 0.5, 0.75
		local frameIndices4 = {1, 16, 31, 46}  -- Frames 0, 15, 30, 45 (1-indexed: 1, 16, 31, 46)
		local expectedPositions4 = {
			Vector(0, 0, 15),    -- angle = 0¬∞ (frame 0, t=0)
			Vector(15, 0, 0),     -- angle = 90¬∞ (frame 15, t=0.25)
			Vector(0, 0, -15),    -- angle = 180¬∞ (frame 30, t=0.5)
			Vector(-15, 0, 0)     -- angle = 270¬∞ (frame 45, t=0.75)
		}

		local allMatch4 = true
		local mismatches4 = {}

		for i = 1, #frameIndices4 do
			local frameIdx = frameIndices4[i]
			if frameIdx > #cylindricalPath then
				allMatch4 = false
				table.insert(mismatches4, "Frame " .. (frameIdx - 1) .. ": Path too short")
			else
				local actualPos = cylindricalPath[frameIdx].position
				local expectedPos = expectedPositions4[i]

				if actualPos then
					local tolerance = 0.01
					local dx = math.abs(actualPos.x - expectedPos.x)
					local dy = math.abs(actualPos.y - expectedPos.y)
					local dz = math.abs(actualPos.z - expectedPos.z)

					if dx > tolerance or dy > tolerance or dz > tolerance then
						allMatch4 = false
						table.insert(mismatches4, string.format(
							"Frame %d (angle ~%d¬∞): Expected %s, got %s (diff: %.3f, %.3f, %.3f)",
							frameIdx - 1, (i - 1) * 90, tostring(expectedPos), tostring(actualPos), dx, dy, dz
						))
					end
				else
					allMatch4 = false
					table.insert(mismatches4, "Frame " .. (frameIdx - 1) .. ": Missing position")
				end
			end
		end

		if allMatch4 then
			test4Passed = true
			printTestResult("Cylindrical Coordinate Transformation", true, "All key positions (0¬∞, 90¬∞, 180¬∞, 270¬∞) match expected values")
			broadcast("‚úÖ Test 4 Passed: Cylindrical coordinates transform correctly", {0, 1, 0})
		else
			errorMessage4 = "Position mismatches:\n  " .. table.concat(mismatches4, "\n  ")
			printTestResult("Cylindrical Coordinate Transformation", false, errorMessage4)
			broadcast("‚ùå Test 4 Failed: Position mismatches detected", {1, 0, 0})
		end
	else
		errorMessage4 = "Failed to generate path or path has fewer than 61 frames"
		if cylindricalPath == "DEFER" then
			errorMessage4 = "Path generation was deferred (unexpected for static coordinates)"
		elseif cylindricalPath and #cylindricalPath > 0 then
			errorMessage4 = "Path has only " .. #cylindricalPath .. " frames, expected 61"
		end
		printTestResult("Cylindrical Coordinate Transformation", false, errorMessage4)
		broadcast("‚ùå Test 4 Failed: " .. errorMessage4, {1, 0, 0})
	end

	-- Summary of validation tests
	broadcast("‚úÖ Validation Tests (1-4) Complete", {0, 1, 0})
	print("\n" .. string.rep("=", 70))
	print("VALIDATION TESTS COMPLETE")
	print(string.rep("=", 70))
	print("Basic validation tests completed. Proceeding to visual demonstrations...")
	print(string.rep("=", 70))

	-- Visual demonstration tests - These execute actual lerps and need to be sequenced
	broadcast("üé¨ Starting Visual Demonstration Tests", {1, 1, 0.5})
	print("\n--- Visual Demonstration Tests (Sequenced) ---")
	print("These tests will run sequentially so you can observe each animation.")
	print("Waiting 2 seconds before starting animations...\n")

	-- Get objects for animation tests
	local testLight = getTestObject(TEST_GUIDS.TEST_LIGHT, "Test Light")
	local testBlock = getTestObject(TEST_GUIDS.TEST_BLOCK, "Test Block")
	local centerObj = getTestObject(TEST_GUIDS.TEST_CENTER_OBJ, "Center Object")
	local targetObj = getTestObject(TEST_GUIDS.TEST_TARGET_OBJ, "Target Object")

	-- Build sequence of animation tests
	local animationSequence = {}

	-- Initial delay before first animation
	table.insert(animationSequence, function()
		broadcast("‚è≥ Preparing animations...", {0.8, 0.8, 0.8})
		return 2.0  -- 2 second pause before starting
	end)

	-- Helper: Execute a test from TEST_PARAMETERS
	-- @param testName string Name of test in TEST_PARAMETERS
	-- @param objects table Map of object names to actual objects
	-- @return function|nil Test function to add to sequence, or nil if objects missing
	local function createTestFromParameters(testName, objects)
		local params = TEST_PARAMETERS[testName]
		if not params then
			U.error("createTestFromParameters", "Test not found: " .. testName)
			return nil
		end

		-- Get the object to move
		local objToMove = objects[params.objectToMove]
		if not objToMove then
			printTestResult(testName, false, "Missing object: " .. (params.objectToMove or "objectToMove not specified"))
			return nil
		end

		-- Resolve start data (needed for relative end values)
		local startData = resolveTestData(params.start, objects, nil, params.coordinateSystem, params.objectToMove)
		-- Resolve end data (may use startData for relative values)
		local endData = resolveTestData(params.endVal, objects, startData, params.coordinateSystem, params.objectToMove)

		-- Check if any required objects are missing
		local missingObjects = {}
		if startData.center and U.Type(startData.center) == "string" then
			table.insert(missingObjects, startData.center)
		end
		if endData.center and U.Type(endData.center) == "string" then
			table.insert(missingObjects, endData.center)
		end
		if startData.orientation and U.Type(startData.orientation) == "string" then
			table.insert(missingObjects, startData.orientation)
		end
		if endData.orientation and U.Type(endData.orientation) == "string" then
			table.insert(missingObjects, endData.orientation)
		end

		for _, objName in ipairs(missingObjects) do
			if not objects[objName] then
				printTestResult(testName, false, "Missing object: " .. objName)
				return nil
			end
		end

		-- Return two functions: one for initialization/pause, one for the lerp
		local initFunction = function()
			-- Verify objToMove is still valid
			if not objToMove then
				printTestResult(testName, false, "Object to move became invalid")
				return nil
			end

			local testDisplayName = testName:gsub("_", " ")
			broadcast("üåç Test: " .. testDisplayName, {0.8, 0.5, 1})
			print("\n--- Test: " .. testDisplayName .. " ---")

			-- Initialize: Move object to starting position and orientation
			local startCenter = resolveTestData({center = startData.center}, objects, nil, params.coordinateSystem, params.objectToMove).center
			if not U.isGameObject(startCenter) then
				startCenter = Vector(startCenter)
			end

			-- Convert start position to XYZ (stored in closure)
			startPosXYZ = nil
			if startData.position then
				startPosXYZ = U.resolvePositionData({position = startData.position}, params.coordinateSystem, startCenter)
			end

			-- Set starting position FIRST (use setPosition for immediate placement during initialization)
			if startPosXYZ and objToMove then
				-- Use setPosition (not setPositionSmooth) for immediate placement during initialization
				-- This ensures the object is at the correct position before calculating orientation
				local success = pcall(function() objToMove.setPosition(startPosXYZ) end)
				if not success then
					printTestResult(testName, false, "Failed to set starting position")
					return nil
				end
				print("Moved object to starting position: " .. tostring(startPosXYZ))

				-- Return the object so U.RunSequence will wait for it to be at rest
				-- This ensures the object is fully settled before the next function runs
				return objToMove
			else
				printTestResult(testName, false, "Failed to resolve start position or object is nil")
				return nil
			end
		end

		-- Function to set orientation after object is at rest
		local orientationFunction = function()
			local testDisplayName = testName:gsub("_", " ")
			-- Set starting orientation AFTER position is set and object is at rest
			if startData.orientation and objToMove and startPosXYZ then
				local startRot
				if U.isGameObject(startData.orientation) then
					-- Calculate look-at rotation using helper from util library
					-- Use the starting position we just set
					local success, targetPos = pcall(function() return startData.orientation.getPosition() end)
					if success and targetPos then
						local rotSuccess, rotResult = pcall(function()
							return U.lookAtRotation(startPosXYZ, targetPos)
						end)
						if rotSuccess and rotResult then
							startRot = rotResult
						else
							print("Warning: U.lookAtRotation failed: " .. tostring(rotResult))
							startRot = Vector(0, 0, 0)
						end
					else
						print("Warning: Failed to get target position for orientation calculation")
						startRot = Vector(0, 0, 0)
					end
				else
					-- Direct Vector value
					startRot = Vector(startData.orientation)
				end
				if startRot then
					local success, err = pcall(function() objToMove.setRotationSmooth(startRot, false, false) end)
					if not success then
						print("Warning: Failed to set rotation for " .. testName .. ": " .. tostring(err))
					end
				end
			end

			-- Broadcast initialization complete
			print("Object moved to starting position.")
			local success = pcall(function()
				broadcast("üìç Initialized: " .. testDisplayName .. " - Waiting for continuation...", {0.7, 0.7, 1})
			end)
			if not success then
				print("Warning: Failed to broadcast initialization message")
			end
			print("üí° To continue, type in console: continueTest()")

			-- Set up interactive pause
			testWaitingForContinue = true  -- Signal that we're waiting

			-- Return immediately - the lerp function will handle waiting
			return 0.1
		end

		local lerpFunction = function()
			local testDisplayName = testName:gsub("_", " ")

			-- Wait for continuation to be triggered
			if testWaitingForContinue then
				broadcast("‚è≥ Waiting for continuation: " .. testDisplayName, {0.8, 0.8, 0.8})
				print("Waiting for continueTest() to be called...")
				print("   Type in console: continueTest()")

				-- Wait for continuation by yielding in a loop
				-- Since we're already in a coroutine, we can't use U.waitUntil (which starts its own coroutine)
				local waitStartTime = os.time()
				local maxWaitSeconds = 300  -- 5 minutes

				while testWaitingForContinue do
					local elapsed = os.time() - waitStartTime
					if elapsed >= maxWaitSeconds then
						broadcast("‚è±Ô∏è Test timeout: " .. testDisplayName, {1, 0.5, 0})
						print("Test timed out after 5 minutes. Use continueTest() to continue manually.")
						return 1.0
					end
					coroutine.yield(0)  -- Yield one frame and check again next frame
				end

				print("Continuation received, proceeding with animation...")
			end

			-- Broadcast animation start
			broadcast("‚ñ∂Ô∏è " .. testDisplayName .. " Starting Animation", {0.8, 0.5, 1})


			-- Generate path (will return "DEFER" if Object references present)
			local path = U.GetEasedPath(startData, endData, params.duration, params.ease, params.easeIntensity, params.coordinateSystem)

			local lerpDuration
			if path == "DEFER" then
				-- Use deferred execution for Object references
				lerpDuration = U.LerpDeferred(startData, endData, params.duration, params.ease, params.easeIntensity, params.coordinateSystem, function(step)
					if objToMove and step then
						if step.position then
							objToMove.setPositionSmooth(step.position, false, false)
						end
						if step.orientation then
							objToMove.setRotationSmooth(step.orientation, false, false)
						end
					end
				end)
			else
				-- Use pre-computed path
				lerpDuration = U.LerpPath(path, function(step)
					if objToMove and step then
						if step.position then
							objToMove.setPositionSmooth(step.position, false, false)
						end
						if step.orientation then
							objToMove.setRotationSmooth(step.orientation, false, false)
						end
					end
				end)
			end

			local parallelDuration = runParallelLerps(params.parallelLerps, objects, objToMove, params.duration, params.ease)
			local totalDuration = math.max(lerpDuration or 0, parallelDuration or 0)

			if totalDuration > 0 then
				printTestResult(testDisplayName, true, "Lerp started, duration: " .. lerpDuration .. "s")
				broadcast("‚ñ∂Ô∏è " .. testDisplayName .. " Running: " .. totalDuration .. "s", {0.8, 0.5, 1})
				return totalDuration + 1.0  -- Wait for animation + 1 second pause
			else
				printTestResult(testDisplayName, false, "Failed to start lerp")
				broadcast("‚ùå " .. testDisplayName .. " Failed: Could not start lerp", {1, 0, 0})
				return 1.0
			end
		end

		-- Return three functions: init (returns object to wait for), orientation (runs after object is at rest), lerp
		return initFunction, orientationFunction, lerpFunction
	end

	-- Build object map for test resolution
	local testObjects = {
		TEST_LIGHT = testLight,
		TEST_BLOCK = testBlock,
		TEST_CENTER_OBJ = centerObj,
		TEST_TARGET_OBJ = targetObj
	}

	-- Test: ORBITING_LIGHT
	local orbitingInit, orbitingOrientation, orbitingLerp = createTestFromParameters("ORBITING_LIGHT", testObjects)
	if orbitingInit and orbitingOrientation and orbitingLerp then
		table.insert(animationSequence, orbitingInit)        -- Initialization (returns object to wait for)
		table.insert(animationSequence, orbitingOrientation) -- Orientation setup (runs after object is at rest)
		table.insert(animationSequence, orbitingLerp)        -- Animation
		table.insert(animationSequence, pauseStep("‚è∏Ô∏è Orbiting Light complete - inspect TEST_LIGHT, then continue."))
	end

	-- Test: CYLINDRICAL_SPIRAL
	local spiralInit, spiralOrientation, spiralLerp = createTestFromParameters("CYLINDRICAL_SPIRAL", testObjects)
	if spiralInit and spiralOrientation and spiralLerp then
		table.insert(animationSequence, spiralInit)        -- Initialization (returns object to wait for)
		table.insert(animationSequence, spiralOrientation) -- Orientation setup (runs after object is at rest)
		table.insert(animationSequence, spiralLerp)       -- Animation
	end

	-- Final summary function
	table.insert(animationSequence, function()
		broadcast("‚úÖ All Animation Tests Complete!", {0, 1, 0})
		print("\n" .. string.rep("=", 70))
		print("EASING TEST SUMMARY")
		print(string.rep("=", 70))
		print("\nRequired Objects (set GUIDs in TEST_GUIDS constant):")
		print("  - TEST_LIGHT: Light object to animate")
		print("  - TEST_BLOCK: Block object (for future tests)")
		print("  - TEST_CENTER_OBJ: Object to use as center for orbital/spiral paths")
		print("  - TEST_TARGET_OBJ: Object to orbit around and face")
		print("\nNote: Tests that require objects will be skipped if objects are missing.")
		print("Replace placeholder GUIDs in TEST_GUIDS with actual object GUIDs from your scene.")
		print(string.rep("=", 70))
		return 0.5
	end)

		-- Execute animation sequence if we have any tests
		if #animationSequence > 1 then  -- More than just the initial delay
			broadcast("Starting " .. (#animationSequence - 1) .. " visual demonstration(s)...", {1, 1, 0.5})
			print("Starting animation sequence with " .. (#animationSequence - 1) .. " visual demonstration(s)...")
			print("Tests will demonstrate:")
			print("  - Orbiting Light: Spherical coordinates with object-facing orientation")
			print("  - Cylindrical Spiral: Spiraling in with fixed downward orientation")
			U.RunSequence(animationSequence)
	else
		print("\nNo animation tests to run (missing required objects)")
		-- Print summary immediately if no animations
		print("\n" .. string.rep("=", 70))
		print("EASING TEST SUMMARY")
		print(string.rep("=", 70))
		print("\nRequired Objects (set GUIDs in TEST_GUIDS constant):")
		print("  - TEST_LIGHT: Light object to animate")
		print("  - TEST_BLOCK: Block object (for future tests)")
		print("  - TEST_CENTER_OBJ: Object to use as center for orbital/spiral paths")
		print("  - TEST_TARGET_OBJ: Object to orbit around and face")
		print("\nNote: Tests that require objects will be skipped if objects are missing.")
		print("Replace placeholder GUIDs in TEST_GUIDS with actual object GUIDs from your scene.")
		print(string.rep("=", 70))
	end
end

--[[
    Test Runner - Run All Tests
]]

--- Run all test functions in sequence
-- Executes all available test functions using U.RunSequence
-- Tests are run in a logical order: foundation tests first, then integration tests
function DEBUG.runTests()
    printTestHeader("Running All Tests")
    DEBUG.logToFile("INFO", "Starting runTests() - Running all test suites", "debug_log")

    local testResults = {}  -- Store results for summary

    -- Helper: Broadcast message to all players
    local function broadcast(message, color)
        color = color or {1, 1, 1}  -- Default white
        broadcastToAll(message, color)
        print("üì¢ " .. message)
    end

    -- Helper: Run a single test and capture results
    local function runSingleTest(testName, testFunc)
        broadcast("üß™ Running: " .. testName, {0.8, 0.8, 1})
        print("\n" .. string.rep("=", 60))
        print("TEST SUITE: " .. testName)
        print(string.rep("=", 60))

        -- Note: Individual tests log their own results via logTestToFile
        -- We can't easily capture pass/fail counts from individual tests
        -- So we just run them and let them log
        local success, result = pcall(testFunc)
        if not success then
            print("‚ùå ERROR running " .. testName .. ": " .. tostring(result))
            DEBUG.logToFile("ERROR", "Test " .. testName .. " failed with error: " .. tostring(result), "debug_log")
            return false
        end
        return true
    end

    -- Test sequence
    local testSequence = {}

    -- Step 1: Initial broadcast
    table.insert(testSequence, function()
        broadcast("üöÄ Starting All Tests Suite", {1, 1, 0.5})
        return 2.0
    end)

    -- Step 2: Constants test (foundation)
    table.insert(testSequence, function()
        local success = runSingleTest("Constants Module", DEBUG.testConstants)
        table.insert(testResults, {name = "Constants Module", success = success})
        return 5.0  -- Wait for test to complete
    end)

    -- Step 3: State test (foundation)
    table.insert(testSequence, function()
        local success = runSingleTest("State Management", DEBUG.testState)
        table.insert(testResults, {name = "State Management", success = success})
        return 5.0
    end)

    -- Step 4: Zones test (foundation, with user interaction)
    table.insert(testSequence, function()
        local success = runSingleTest("Zone Management", DEBUG.testZones)
        table.insert(testResults, {name = "Zone Management", success = success})
        return 60.0  -- Zones test requires user interaction, give it more time
    end)

    -- Step 5: Scenes test
    table.insert(testSequence, function()
        local success = runSingleTest("Scene Management", DEBUG.testScenes)
        table.insert(testResults, {name = "Scene Management", success = success})
        return 10.0
    end)

    -- Step 6: Main module test
    table.insert(testSequence, function()
        local success = runSingleTest("Main Module", DEBUG.testMain)
        table.insert(testResults, {name = "Main Module", success = success})
        return 5.0
    end)

    -- Step 7: UI test
    table.insert(testSequence, function()
        local success = runSingleTest("UI Display Updates", DEBUG.testUI)
        table.insert(testResults, {name = "UI Display Updates", success = success})
        return 5.0
    end)

    -- Step 8: Lighting and signals test (long-running with animations)
    table.insert(testSequence, function()
        local success = runSingleTest("Lighting & Signal Fires", DEBUG.testLightingAndSignals)
        table.insert(testResults, {name = "Lighting & Signal Fires", success = success})
        return 180.0  -- Lighting test takes 2-3 minutes
    end)

    -- Step 9: Final summary
    table.insert(testSequence, function()
        broadcast("‚úÖ All Tests Complete!", {0, 1, 0})
        print("\n" .. string.rep("=", 60))
        print("TEST SUITE SUMMARY")
        print(string.rep("=", 60))
        local successCount = 0
        for _, result in ipairs(testResults) do
            local status = result.success and "‚úì" or "‚úó"
            print(status .. " " .. result.name)
            if result.success then successCount = successCount + 1 end
        end
        print(string.rep("-", 60))
        print("Completed: " .. #testResults .. " test suites")
        print("Successful: " .. successCount)
        print("Failed: " .. (#testResults - successCount))
        print(string.rep("=", 60))

        local summary = string.format("All Tests: %d/%d test suites completed successfully", successCount, #testResults)
        DEBUG.logToFile("INFO", summary, "debug_log")
        DEBUG.logTestToFile("All Tests Suite", successCount == #testResults, summary, "test_results")
        return 0
    end)

    -- Execute the sequence
    print("Starting test suite with " .. #testSequence .. " steps...")
    print("This will run all available tests in sequence.")
    print("Some tests require user interaction - watch for broadcast prompts.\n")
    print("Estimated time: 5-10 minutes (depending on user interaction)\n")

    -- Use U.RunSequence to execute all test steps
    U.RunSequence(testSequence)
end

--[[
    Integration Tests
]]

--- Test full module integration
-- Tests that all modules work together
function DEBUG.testIntegration()
    printTestHeader("Full Integration Test")
    DEBUG.logToFile("INFO", "Starting testIntegration() - Running all tests", "debug_log")

    -- Reset state to clean defaults before testing
    print("Resetting game state to clean defaults...")
    S.resetGameState()

    print("Running integration test sequence...")

    -- Step 1: Set game state
    print("\n1. Setting game state...")
    local testColor = getFirstSeatedPlayerColor()
    if not testColor then
        print("   ‚úó ERROR: No seated players found for integration test")
        return
    end
    local playerID = S.getPlayerID(testColor)
    if not playerID then
        print("   ‚úó ERROR: Could not find player ID for color: " .. testColor)
        return
    end
    S.setPlayerVal(testColor, "hunger", 3)
    S.setStateVal(C.Phases.SCENE, "currentPhase")
    print("   ‚úì State set (using player: " .. testColor .. ", ID: " .. playerID .. ")")

    -- Step 2: Load scene
    print("\n2. Loading scene...")
    local sceneSuccess = Scenes.loadScene("elysium")
    print("   " .. (sceneSuccess and "‚úì" or "‚úó") .. " Scene loaded")

    -- Step 3: Advance phase
    print("\n3. Advancing phase...")
    M.advancePhase(C.Phases.COMBAT)
    print("   ‚úì Phase advanced")

    -- Step 4: Update UI
    print("\n4. Updating UI...")
    updateUIDisplays()
    print("   ‚úì UI updated")

    -- Step 5: Verify state
    print("\n5. Verifying final state...")
    local finalHunger = S.getPlayerVal(testColor, "hunger")
    local finalPhase = S.getStateVal("currentPhase")
    local finalScene = Scenes.getCurrentScene()

    print("   Final hunger (" .. testColor .. "): " .. tostring(finalHunger))
    print("   Final phase: " .. tostring(finalPhase))
    print("   Final scene: " .. tostring(finalScene))

    local allGood = (finalHunger == 3 and finalPhase == C.Phases.COMBAT and finalScene == "elysium")
    printTestResult("Integration test", allGood, allGood and "All checks passed" or "Some checks failed")
end

--[[
    State Inspection Functions
]]

--- Display current game state (readable format)
function DEBUG.showState()
    printTestHeader("Current Game State")
    local state = S.getGameState()
    print(JSON.encode_pretty(state))
end

--- Display current scene info
function DEBUG.showScene()
    printTestHeader("Current Scene Info")
    local currentScene = Scenes.getCurrentScene()
    if currentScene then
        local sceneData = Scenes.getScene(currentScene)
        print("Current Scene: " .. currentScene)
        print("Description: " .. (sceneData.description or "N/A"))
        print("\nScene Data:")
        print(JSON.encode_pretty(sceneData))
    else
        print("No scene currently set.")
    end
end

--- Display zone status
function DEBUG.showZones()
    printTestHeader("Zone Status")
    local zonesLocked = S.getStateVal("zones", "allZonesLocked")
    print("Zones Locked: " .. tostring(zonesLocked))
    print("Zone Events Active: " .. tostring(not zonesLocked))
end

--[[
    Quick Test Functions (Single Commands)
]]

--- Quick test: Set player hunger
-- @param color string Player color
-- @param value number Hunger value (0-5)
function DEBUG.setHunger(color, value)
    if not color or not value then
        print("Usage: setHunger(color, value)")
        print("Example: setHunger('Red', 3)")
        return
    end

    local playerID = S.getPlayerID(color)
    if not playerID then
        print("ERROR: Could not find player ID for color: " .. color)
        return
    end

    S.setPlayerVal(color, "hunger", value)
    print("Set " .. color .. " player (ID: " .. playerID .. ") hunger to " .. tostring(value))

    updateUIDisplays()
end

--- Quick test: Change scene
-- @param sceneName string Scene name
function DEBUG.changeScene(sceneName)
    if not sceneName then
        print("Usage: changeScene(sceneName)")
        print("Available scenes: " .. table.concat(Scenes.listScenes(), ", "))
        return
    end

    Scenes.loadScene(sceneName)
    print("Changed scene to: " .. sceneName)
end

--- Quick test: Set phase
-- @param phaseName string Phase name (e.g., "PLAY", "COMBAT")
function DEBUG.setPhase(phaseName)
    if not phaseName then
        print("Usage: setPhase(phaseName)")
        print("Available phases: " .. table.concat(U.getValues(C.Phases), ", "))
        return
    end

    -- Find matching phase constant
    local targetPhase = nil
    for _, phase in pairs(C.Phases) do
        if string.upper(phaseName) == string.upper(phase) or string.upper(phaseName) == string.upper(string.match(phase, "(%w+)$")) then
            targetPhase = phase
            break
        end
    end

    if targetPhase then
        M.advancePhase(targetPhase)
        print("Changed phase to: " .. targetPhase)
    else
        print("Invalid phase name. Available: " .. table.concat(U.getValues(C.Phases), ", "))
    end
end

--[[
    File Logging Functions
    These functions write debug information to files in the workspace using
    the TTS Tools extension's sendExternalMessage API.
]]

--- Logs a message to a file with timestamp
-- @param level string Log level: "INFO", "WARN", "ERROR", "DEBUG"
-- @param message string Message to log
-- @param filename string Optional filename (default: "debug_log")
function DEBUG.logToFile(level, message, filename)
    filename = filename or "debug_log"
    local timestamp = getTimestamp()
    local logEntry = string.format("[%s] [%s] %s\n", timestamp, level, message)

    -- Append to existing cached content
    writeToFile(filename, logEntry, "none", true)
end

--- Logs current game state to a file as JSON
-- @param filename string Optional filename (default: "game_state")
function DEBUG.logStateToFile(filename)
    filename = filename or "game_state"
    local state = S.getGameState()
    local stateJson = JSON.encode_pretty(state)
    local timestamp = getTimestamp()
    local content = string.format("Game State Dump - %s\n%s\n", timestamp, stateJson)

    -- State dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Game state logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs current scene information to a file
-- @param filename string Optional filename (default: "scene_info")
function DEBUG.logSceneToFile(filename)
    filename = filename or "scene_info"
    local currentScene = Scenes.getCurrentScene()
    local scene = Scenes.getScene(currentScene)
    local timestamp = getTimestamp()

    local content = string.format("Scene Information - %s\n", timestamp)
    content = content .. string.format("Current Scene: %s\n", currentScene or "nil")
    if scene then
        content = content .. string.format("Scene Data:\n")
        content = content .. JSON.encode_pretty(scene)
    else
        content = content .. "Scene data not found\n"
    end
    content = content .. "\n"

    -- Scene dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Scene info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs zone information to a file
-- @param filename string Optional filename (default: "zone_info")
function DEBUG.logZonesToFile(filename)
    filename = filename or "zone_info"
    local zonesState = S.getStateVal("zones")
    local timestamp = getTimestamp()

    local content = string.format("Zone Information - %s\n", timestamp)
    if zonesState then
        content = content .. JSON.encode_pretty(zonesState)
    else
        content = content .. "No zone state found\n"
    end
    content = content .. "\n"

    -- Zone dumps are overwritten (not appended) - each dump is a complete snapshot
    writeToFile(filename, content, "auto", false)
    print("DEBUG: Zone info logged to " .. filename .. "." .. LOG_EXTENSION)
end

--- Logs a test result to a file
-- @param testName string Name of the test
-- @param passed boolean Whether the test passed
-- @param details string Optional details
-- @param filename string Optional filename (default: "test_results")
function DEBUG.logTestToFile(testName, passed, details, filename)
    filename = filename or "test_results"
    local timestamp = getTimestamp()
    local status = passed and "PASS" or "FAIL"

    local content = string.format("[%s] %s: %s\n", timestamp, status, testName)
    if details then
        content = content .. string.format("  Details: %s\n", details)
    end
    content = content .. "\n"

    -- Append to existing cached content
    writeToFile(filename, content, "none", true)
end

--- Logs all debug information to separate files
-- Creates: game_state, scene_info, zone_info, and a general debug log
function DEBUG.logAllToFiles()
    print("DEBUG: Logging all information to files...")
    DEBUG.logStateToFile("game_state")
    DEBUG.logSceneToFile("scene_info")
    DEBUG.logZonesToFile("zone_info")
    DEBUG.logToFile("INFO", "Full debug dump completed", "debug_log")
    print("DEBUG: All logs written to " .. LOG_DIR .. "/ directory")
end

--- Clears all log files (writes empty/header content to reset them)
-- Called automatically on game load to start fresh logs
-- Also clears the in-memory cache
function DEBUG.clearAllLogs()
    local timestamp = getTimestamp()
    local sessionHeader = string.format("=== DEBUG LOG SESSION STARTED - %s ===\n\n", timestamp)

    -- Clear the cache
    logCache = {}

    -- Clear each log file by writing session header (overwrite mode)
    writeToFile("debug_log", sessionHeader, "none", false)
    writeToFile("game_state", sessionHeader, "none", false)
    writeToFile("scene_info", sessionHeader, "none", false)
    writeToFile("zone_info", sessionHeader, "none", false)
    writeToFile("test_results", sessionHeader, "none", false)

    print("DEBUG: All log files cleared (new session started)")
end

--[[
    Help/Documentation
]]

--- Display help for all debug functions
function DEBUG.help()
    print("\n" .. string.rep("=", 70))
    print("VTM5E MODULE - DEBUG/TESTING COMMANDS")
    print(string.rep("=", 70))
    print("\nUse these commands in the TTS console with: lua <command>()")
    print("\nTESTING FUNCTIONS:")
    print("  testConstants()          - Test constants module (TOR-3)")
    print("  testState()              - Test state get/set operations (TOR-5)")
    print("  testStatePersistence()   - Test state save/load")
    print("  testScenes()             - Test scene loading and transitions")
    print("  testAllScenes()          - Test all scene presets")
    print("  testZones()              - Test zone activation/deactivation with user interaction")
    print("  testMain()               - Test main module functions")
    print("  testUI()                 - Test UI display updates")
    print("  testUtilities()          - Test utility functions")
    print("  testLightingAndSignals() - Test lighting & signal fires with sequencing")
    print("  testEasing()             - Test easing and path generation functions")
    print("  testLookAt()             - Test look-at rotation (minimal test)")
    print("  testIntegration()        - Full integration test")
    print("  runTests()               - Run all tests in sequence")
    print("\nINSPECTION FUNCTIONS:")
    print("  showState()              - Display current game state (JSON)")
    print("  showScene()              - Display current scene info")
    print("  showZones()              - Display zone status")
    print("\nFILE LOGGING FUNCTIONS:")
    print("  logToFile(level, msg, filename?) - Log a message to file")
    print("  logStateToFile(filename?)       - Log game state to file (JSON)")
    print("  logSceneToFile(filename?)       - Log scene info to file")
    print("  logZonesToFile(filename?)       - Log zone info to file")
    print("  logTestToFile(name, passed, details?, filename?) - Log test result")
    print("  logAllToFiles()                   - Log all debug info to files")
    print("  clearAllLogs()                    - Clear all log files (starts new session)")
    print("\nQUICK SETTERS:")
    print("  setHunger(color, value)  - Set player hunger (e.g., setHunger('Red', 3))")
    print("  changeScene(sceneName)   - Change scene (e.g., changeScene('elysium'))")
    print("  setPhase(phaseName)      - Change phase (e.g., setPhase('PLAY'))")
    print("\nHELP:")
    print("  debugHelp()              - Show this help message")
    print("\n" .. string.rep("=", 70))
end

--[[
    Expose Functions Globally
    These functions can be called from the TTS console via: lua functionName()
    NOTE: In TTS Lua, assigning without 'local' makes variables global.
    No need for _G syntax - just assign directly.
]]

-- Expose all test functions
testConstants = DEBUG.testConstants
testState = DEBUG.testState
testStatePersistence = DEBUG.testStatePersistence
testScenes = DEBUG.testScenes
testAllScenes = DEBUG.testAllScenes
testZones = DEBUG.testZones
testMain = DEBUG.testMain
testUI = DEBUG.testUI
testUtilities = DEBUG.testUtilities
testLightingAndSignals = DEBUG.testLightingAndSignals
testEasing = DEBUG.testEasing
testIntegration = DEBUG.testIntegration
runTests = DEBUG.runTests

-- Expose inspection functions
showState = DEBUG.showState
showScene = DEBUG.showScene
showZones = DEBUG.showZones

-- Expose quick setters
setHunger = DEBUG.setHunger
changeScene = DEBUG.changeScene
setPhase = DEBUG.setPhase

-- Expose file logging functions
logToFile = DEBUG.logToFile
logStateToFile = DEBUG.logStateToFile
logSceneToFile = DEBUG.logSceneToFile
logZonesToFile = DEBUG.logZonesToFile
logTestToFile = DEBUG.logTestToFile
logAllToFiles = DEBUG.logAllToFiles

-- Expose help
debugHelp = DEBUG.help

-- Expose initialization function
initLightingAndSignals = DEBUG.initLightingAndSignals

-- Expose light test functions
testSpawnLightType = DEBUG.testSpawnLightType
testCloneLight = DEBUG.testCloneLight
testInspectLight = DEBUG.testInspectLight
testSpawnLight = DEBUG.testSpawnLight
testCompareStructures = DEBUG.testCompareStructures
findPotentialLights = DEBUG.findPotentialLights

-- Auto-show help on load (optional - comment out if not desired)
-- DEBUG.help()

return DEBUG
