--[[
    Main Game Logic Module (core/main.ttslua)

    Orchestrates game flow, coordinates between modules, and handles high-level game logic.
    Pattern based on Heritage module's manual control approach (NOT automated director).

    This module provides:
    - Player iteration patterns (DRY principle)
    - Manual phase control (Storyteller-driven)
    - Event delegation to other modules
    - Camera and scene control utilities
    - Game initialization and setup sequences
]]

local M = {}
local U = require("lib.util")
local C = require("lib.constants")
local G = require("lib.guids")
local S = require("core.state")
-- Optional: Will be required when lighting/scene modules are integrated
-- local L = require("core.lighting")
-- local Scenes = require("core.scenes")

--[[
    Main initialization entry point
    Called from global.ttslua onLoad() after state is initialized.
    Sets up game systems and prepares for play.
]]
function M.onLoad()
  print("Main: Core module loaded.")
  -- Initialize systems
  M.setupPlayers()
  M.syncPhase()   -- Sync UI/features based on current phase

  print("Main: Module initialization complete.")
end

--[[
    Setup player data structures and roles
    Promotes all players and initializes player-specific game state.
    Pattern from Heritage M.setupPlayers / initialization globals.
]]
function M.setupPlayers()
  print("Main: Setting up players.")

  -- Promote all players (give them full permissions)
  for _, player in ipairs(Player.getPlayers()) do
    player.promoted = true
    print("Main: Promoted player " .. player.color)
  end

  -- Set up tombstone visibility (each player's tombstone invisible to them)
  M.setupTombstoneVisibility()

  -- Make objects on Storyteller table invisible to all players

  U.forEach(
    U.findAboveObject(
      getObjectFromGUID(G.GUIDS.STORYTELLER_TABLE), nil, { box = true, far = true }
    ),
    function(v)
      v.setInvisibleTo({ "Brown", "Orange", "Red", "Pink" })
    end
  )

  -- TODO: Assign Storyteller role (e.g., Black or Brown player)
  -- TODO: Initialize player-specific data in game state (hunger, willpower, health, etc.)
  -- TODO: Set up player-specific UI elements
end

--[[
    Sets up tombstone visibility so each player's tombstone is invisible to them
    This prevents tombstones from blocking a player's view of the table.
    Uses TTS setInvisibleTo() function to hide objects from specific players.
]]
function M.setupTombstoneVisibility()
  print("Main: Setting up tombstone visibility.")

  for _, color in ipairs(C.PlayerColors) do
    local guid = G.GetTombstoneGUID(color)
    if guid then
      local tombstone = getObjectFromGUID(guid)
      if tombstone then
        -- Make this tombstone invisible to the player of this color
        -- The tombstone will still be visible to other players and the Storyteller
        tombstone.setInvisibleTo({ color })
        print("Main: Tombstone for " .. color .. " set invisible to " .. color .. " player")
      else
        print("Main: Warning - Tombstone object not found for " .. color .. " (GUID: " .. guid .. ")")
      end
    else
      print("Main: Warning - No tombstone GUID found for " .. color)
    end
  end

  print("Main: Tombstone visibility setup complete.")
end

--[[
    Execute a function for all players
    DRY pattern for applying logic to all players without code duplication.

    @param func function The function to execute for each player.
                 Signature: func(player, color) where:
                 - player: Player object (e.g., Player.Red)
                 - color: string Player color (e.g., "Red")

    @usage M.forPlayers(function(player, color)
               print("Player " .. color .. " is ready")
           end)

    Pattern from Heritage M.forPlayers
]]
function M.forPlayers(func)
  if type(func) ~= "function" then
    U.AlertGM("M.forPlayers: func parameter must be a function")
    return
  end

  -- Iterate over actually seated players, not all possible colors
  -- This avoids errors when trying to access Player[color] for colors with no seated players
  for _, player in ipairs(Player.getPlayers()) do
    func(player, player.color)
  end
end

--[[
    Sync UI and features based on current game phase
    Updates visibility, enables/disables features, and refreshes displays.
    Called on load and when phase changes.

    Pattern from Heritage M.syncPhase
]]
function M.syncPhase()
  local currentPhase = S.getStateVal("currentPhase")
  if currentPhase == nil then
    print("Main: Warning - Current phase is nil, using SESSION_START")
    currentPhase = C.Phases.SESSION_START
    S.setCurrentPhase(currentPhase)
  end

  print("Main: Syncing phase - " .. currentPhase)

  -- TODO: Phase-specific logic
  -- - Update UI visibility based on phase
  -- - Enable/disable zone event handlers
  -- - Update lighting for scene
  -- - Show/hide phase-specific UI elements

  -- Example: Hide/show zones based on phase
  -- if currentPhase == C.Phases.SETUP then
  --     -- Show setup zones
  -- else
  --     -- Hide setup zones
  -- end
end

--[[
    Manually advance to a new game phase
    Updates game state, triggers phase-specific setup, and syncs UI.
    This is the manual control pattern (Storyteller-driven, not automated).

    @param newPhase string The new phase to transition to (e.g., C.Phases.PLAY)

    @usage M.advancePhase(C.Phases.PLAY)

    Pattern from Heritage manual phase functions (gameSETUP, gameSTART, etc.)
]]
function M.advancePhase(newPhase)
  if type(newPhase) ~= "string" then
    U.AlertGM("M.advancePhase: newPhase must be a string")
    return
  end

  -- Validate phase against constants
  local isValidPhase = false
  for _, phase in pairs(C.Phases) do
    if phase == newPhase then
      isValidPhase = true
      break
    end
  end

  if not isValidPhase then
    U.AlertGM("M.advancePhase: Invalid phase '" .. tostring(newPhase) .. "'")
    return
  end

  local oldPhase = S.getStateVal("currentPhase")
  print("Main: Advancing phase from " .. tostring(oldPhase) .. " to " .. newPhase)

  -- Update state
  S.setCurrentPhase(newPhase)

  -- Trigger phase-specific setup
  -- TODO: Add phase transition logic (lighting changes, UI updates, etc.)
  -- Example:
  -- if newPhase == C.Phases.PLAY then
  --     -- Activate zones, update lighting, etc.
  -- end

  -- Sync UI and features
  M.syncPhase()

  print("Main: Phase advancement complete.")
end

--[[
    Set camera view for a player
    Provides cinematic camera control for dramatic effect.

    @param player Player|string The player object or color string (e.g., Player.Red or "Red")
    @param cameraMode string The camera preset name from C.CameraAngles (e.g., "OVERVIEW")
    @param lookAtPos Vector3 Optional. Specific position to look at. If nil, uses preset from constants.

    @usage M.setCamera(Player.Red, "OVERVIEW")
    @usage M.setCamera("ALL", "GM_VIEW") -- Set camera for all players
    @usage M.setCamera("Red", nil, Vector(0, 5, 0)) -- Custom look-at position

    Pattern from Heritage M.setCamera
]]
function M.setCamera(player, cameraMode, lookAtPos)
  -- Handle "ALL" case
  if player == nil or player == "ALL" then
    M.forPlayers(function(p, color)
      M.setCamera(p, cameraMode, lookAtPos)
    end)
    return
  end

  -- Convert string color to Player object
  if type(player) == "string" then
    local playerColor = player     -- Save original string for error message
    -- Safely check if player color exists before accessing
    if not U.isIn(playerColor, Player.getAvailableColors()) then
      U.AlertGM("M.setCamera: Invalid player color '" .. playerColor .. "'")
      return
    end
    player = Player[playerColor]
    if player == nil then
      U.AlertGM("M.setCamera: No player seated in color '" .. playerColor .. "'")
      return
    end
  end

  if not U.isPlayer(player) then
    U.AlertGM("M.setCamera: Invalid player object")
    return
  end

  -- Get camera preset from constants
  local cameraPreset = nil
  if cameraMode and C.CameraAngles[cameraMode] then
    cameraPreset = C.CameraAngles[cameraMode]
  end

  if cameraPreset == nil and lookAtPos == nil then
    U.AlertGM("M.setCamera: Invalid camera mode '" .. tostring(cameraMode) .. "' and no lookAtPos provided")
    return
  end

  -- Set camera mode to ThirdPerson for cinematic control
  player.setCameraMode("ThirdPerson")

  -- Build camera data table for lookAt() - must include position, pitch, yaw, and distance
  local cameraData = nil
  if lookAtPos ~= nil then
    -- Custom position provided - use it with defaults for pitch/yaw/distance
    cameraData = {
      position = lookAtPos,
      pitch = 0,
      yaw = 0,
      distance = 40
    }
  elseif cameraPreset ~= nil then
    -- Use full camera preset data (position, pitch, yaw, distance)
    -- Clone to avoid modifying the original preset
    cameraData = U.clone(cameraPreset)
    if cameraData.position == nil then
      U.AlertGM("M.setCamera: Camera preset '" .. tostring(cameraMode) .. "' has no position defined")
      return
    end
  end

  if cameraData and cameraData.position then
    -- lookAt() accepts a table with position, pitch, yaw, and distance
    player.lookAt(cameraData)
    -- Reset to ThirdPerson after brief delay (prevents camera snapping back)
    Wait.time(function()
      player.setCameraMode("ThirdPerson")
    end, 0.5)
  end
end

--[[
    Handle object drop events
    Delegates to appropriate modules based on object type and context.

    @param playerColor string The color of the player who dropped the object
    @param droppedObject Object The object that was dropped
    @param zone Object Optional. The scripting zone the object entered (if any)

    Pattern from Heritage event delegation (onObjectDrop, onObjectEnterContainer)
]]
function M.onObjectDrop(playerColor, droppedObject, zone)
  if droppedObject == nil then return end

  print("Main: Object dropped - " .. droppedObject.name ..
    (zone and (" in zone " .. zone.name) or "") ..
    " by player " .. tostring(playerColor))

  -- TODO: Add VTM5E-specific drop logic
  -- - Check if object has specific tags (e.g., "Dice", "Token", "Card")
  -- - Handle dice roller interactions
  -- - Handle token placement in zones
  -- - Update game state based on object placement

  -- Example:
  -- if droppedObject.hasTag("Dice") then
  --     -- Handle dice-specific logic
  -- elseif zone and zone.hasTag("PlayerZone") then
  --     -- Handle zone-specific logic via Z module
  -- end
end

--[[
    Handle player actions (custom hotkeys, button presses, etc.)
    Delegates to appropriate handlers based on action type.

    @param playerColor string The color of the player performing the action
    @param action string The action identifier (e.g., "rollDice", "useDiscipline")
    @param clickState table Optional. Additional context (object clicked, position, etc.)

    Pattern from Heritage M.onPlayerAction
]]
function M.onPlayerAction(playerColor, action, clickState)
  print("Main: Player action - " .. tostring(playerColor) .. ", " .. tostring(action))

  -- TODO: Add VTM5E-specific action handlers
  -- - Dice rolling
  -- - Discipline activation
  -- - Willpower/hunger management
  -- - Scene interaction

  -- Example:
  -- if action == "rollDice" then
  --     -- Trigger dice roller logic
  -- elseif action == "useDiscipline" then
  --     -- Handle discipline usage
  -- end
end

-- Legacy alias for backwards compatibility (if needed)
M.Initialize = M.onLoad

return M
