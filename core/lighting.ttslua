--[[
    Lighting Control Module (core/lighting.ttslua)

    Handles dynamic lighting control for TTS light objects with smooth transitions.
    Extracted and adapted from Kings Dilemma lighting module patterns.

    This module provides:
    - Light mode system (predefined lighting configurations)
    - Smooth transitions using coroutine-based interpolation
    - State persistence (saves current light modes)
    - Light object lookup and component access
    - Batch operations (apply modes to multiple lights)

    Light modes are stored in L.LIGHTMODES table and can be defined per-light.
    Each mode specifies: enabled, color, range, angle, intensity, rotation, position.
]]

local L = {}
local U = require("lib.util")
local S = require("core.state")
local C = require("lib.constants")
local G = require("lib.guids")

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

-- Default transition time for light mode changes (in seconds)
local DefaultTransitionTime = 0.5

-- ============================================================================
-- LIGHT MODE DEFINITIONS
-- ============================================================================

--- Light Mode Definitions Table
--
-- Each light can have multiple modes (e.g., "OFF", "STANDARD", "ambient", "bright", "tension").
-- Modes can be:
--   - Tables: Static mode data {enabled=true, color=Color.White, ...}
--   - Functions: Dynamic modes that calculate values at runtime: function() return {...} end
--   - Strings: Default mode key (e.g., default = "ambient")
--
-- Mode properties:
--   - enabled (boolean): Whether light is on/off
--   - color (Color): Light color (Color object or table {r,g,b})
--   - range (number): Light range/radius
--   - angle (number): Spotlight angle (degrees)
--   - intensity (number): Light intensity/brightness
--   - rotation (Vector): Light rotation {x,y,z}
--   - position (Vector): Light position {x,y,z}
--
-- Special properties (at light definition level, not mode level):
--   - default (string): Default mode to use when mode is "default"
--   - isPlayerLight (boolean): If true, supports per-player modes
--   - isSpawned (boolean): If true, waits for light to spawn before applying
--   - loadRotation (Vector): Initial rotation when light loads
--   - guid (string): Required - GUID of the light object (all lights must have GUID)
--
-- @usage L.LIGHTMODES.playerLightBrown = {
--     guid = "f251e0",  -- Use GUID lookup instead of tags
--     isPlayerLight = true,
--     default = "OFF",
--     OFF = {enabled=false, rotation=Vector(0,-72,0), position=Vector(-36.12,0,-110), ...},
--     STANDARD = {enabled=true, rotation=Vector(0,-72,60), position=Vector(-29.75,22.6,-90), ...}
-- }
L.LIGHTMODES = {
    -- Player lights (per-player spotlights)
    -- These lights are found by GUID, not by tag
    -- Each light has OFF and STANDARD modes
    playerLightBrown = {
        guid = G.GUIDS.PLAYER_LIGHT_BROWN,
        isPlayerLight = true,
        default = "OFF",
        OFF = {
            enabled = false,
            rotation = Vector(0, -72, 0),
            position = Vector(-36.12, 0, -110),
            range = 40,
            angle = 0,
            intensity = 0
        },
        STANDARD = {
            enabled = true,
            rotation = Vector(0, -72, 60),
            position = Vector(-29.75, 22.6, -90),
            range = 40,
            angle = 90,
            intensity = 10
        }
    },
    playerLightOrange = {
        guid = G.GUIDS.PLAYER_LIGHT_ORANGE,
        isPlayerLight = true,
        default = "OFF",
        OFF = {
            enabled = false,
            rotation = Vector(0.00, -36.00, 0.00),
            position = Vector(-80.70, 0.00, -61.95),
            range = 40,
            angle = 0,
            intensity = 0
        },
        STANDARD = {
            enabled = true,
            rotation = Vector(0.00, -36.00, 59.46),
            position = Vector(-71.14, 22.60, -55.00),
            range = 40,
            angle = 90,
            intensity = 10
        }
    },
    playerLightRed = {
        guid = G.GUIDS.PLAYER_LIGHT_RED,
        isPlayerLight = true,
        default = "OFF",
        OFF = {
            enabled = false,
            rotation = Vector(0.00, 0.00, 0.00),
            position = Vector(-106.17, 0.00, 0.00),
            range = 40,
            angle = 0,
            intensity = 0
        },
        STANDARD = {
            enabled = true,
            rotation = Vector(0.00, 0.00, 59.46),
            position = Vector(-86.17, 22.60, 0.00),
            range = 40,
            angle = 90,
            intensity = 10
        }
    },
    playerLightPink = {
        guid = G.GUIDS.PLAYER_LIGHT_PINK,
        isPlayerLight = true,
        default = "OFF",
        OFF = {
            enabled = false,
            rotation = Vector(0.00, 36.00, 0.00),
            position = Vector(-80.70, 0.00, 61.95),
            range = 40,
            angle = 0,
            intensity = 0
        },
        STANDARD = {
            enabled = true,
            rotation = Vector(0.00, 36.00, 59.46),
            position = Vector(-71.14, 22.60, 55.00),
            range = 40,
            angle = 90,
            intensity = 10
        }
    },
    playerLightPurple = {
        guid = G.GUIDS.PLAYER_LIGHT_PURPLE,
        isPlayerLight = true,
        default = "OFF",
        OFF = {
            enabled = false,
            rotation = Vector(0.00, 72.00, 0.00),
            position = Vector(-36.12, 0.00, 110),
            range = 40,
            angle = 0,
            intensity = 0
        },
        STANDARD = {
            enabled = true,
            rotation = Vector(0.00, 72.00, 60),
            position = Vector(-29.75, 22.60, 90),
            range = 40,
            angle = 90,
            intensity = 10
        }
    }
}

-- ============================================================================
-- INTERNAL HELPER FUNCTIONS
-- ============================================================================

--- Gets the Light component from a TTS light object
-- TTS lights have a nested structure: object -> child -> grandchild -> Light component
-- This function navigates that structure to access the Light component.
-- @param light Object The light object
-- @param isSilent boolean If true, returns nil on error instead of throwing
-- @return Component|nil The Light component, or nil if not found/error
local function getLightComponent(light, isSilent)
    local lComp
    local success, err = pcall(function()
        lComp = light.getChildren()[1].getChildren()[2].getComponents()[2]
    end)

    if success and lComp then
        return lComp
    elseif isSilent then
        return nil
    end

    -- Detailed error checking if silent mode off
    U.Val("getLightComponent", light, U.isGameObject(light), "Invalid Light Object")
    local children = light.getChildren()
    U.Val("getLightComponent", {light = light, children = children}, #children > 0, "Light has no Children")
    local grandchildren = children[1].getChildren()
    U.Val("getLightComponent", {light = light, grandchildren = grandchildren}, #grandchildren > 1,
        "Light has too few Grandchildren")
    local components = grandchildren[2].getComponents()
    U.Val("getLightComponent", {light = light, components = components}, #components > 1,
        "Light has too few components")
    U.Val("getLightComponent", {light = light, comp = components[2]}, components[2].name == "Light",
        "Can't find 'Light' component")
    return components[2]
end

--- Finds a light object by GUID
-- GUID is required for all lights - throws error if GUID is not defined in light data.
-- @param lightName string The light name to search for (must exist in L.LIGHTMODES)
-- @param isSilent boolean If true, returns nil on error instead of throwing
-- @return Object|nil The light object, or nil if not found
local function getLight(lightName, isSilent)
    local lData = L.LIGHTMODES[lightName]
    if not lData then
        if isSilent then
            return nil
        else
            U.Val("getLight", lightName, false, "Light mode not found: " .. tostring(lightName))
        end
    end

    -- GUID is required for all lights
    if not lData.guid then
        if isSilent then
            return nil
        else
            error("getLight: Light '" .. tostring(lightName) .. "' must have a GUID defined in LIGHTMODES")
        end
    end

    local light = getObjectFromGUID(lData.guid)
    if light == nil then
        if isSilent then
            return nil
        else
            U.Val("getLight", {lightName, guid = lData.guid}, false, "Light object not found for GUID: " .. tostring(lData.guid))
        end
    end
    return light
end

--- Gets all lights matching a tag (or all lights if no tag)
-- @param tag string|nil Optional tag to filter by
-- @return table Array of light objects
local function getAllLights(tag)
    local allObjects = getObjects()
    return U.filter(allObjects, function(obj)
        if obj.getChildren == nil then return false end
        local children = obj.getChildren()
        if #children == 0 then return false end
        if not string.match(children[1].name or "", "^spotlight") then return false end
        if getLightComponent(obj, true) == nil then return false end
        if tag and not obj.hasTag(tag) then return false end
        return true
    end)
end

--- Sets light component property directly (low-level)
local function setEnabled(light, enabled)
    local comp = getLightComponent(light, true)
    if comp then comp.set("enabled", enabled) end
end

local function setRange(light, range)
    local comp = getLightComponent(light, true)
    if comp then comp.set("range", range) end
end

local function setIntensity(light, intensity)
    local comp = getLightComponent(light, true)
    if comp then comp.set("intensity", intensity) end
end

local function setColor(light, color)
    local comp = getLightComponent(light, true)
    if comp then comp.set("color", Color(color)) end
end

local function setAngle(light, angle)
    local comp = getLightComponent(light, true)
    if comp then comp.set("spotAngle", angle) end
end

--- Gets light component property directly (low-level)
local function getEnabled(light)
    local comp = getLightComponent(light, true)
    return comp and comp.get("enabled") or false
end

local function getRange(light)
    local comp = getLightComponent(light, true)
    return comp and comp.get("range") or 0
end

local function getIntensity(light)
    local comp = getLightComponent(light, true)
    return comp and comp.get("intensity") or 0
end

local function getColor(light)
    local comp = getLightComponent(light, true)
    return comp and comp.get("color") or Color.White
end

local function getAngle(light)
    local comp = getLightComponent(light, true)
    return comp and comp.get("spotAngle") or 0
end

-- ============================================================================
-- CORE LIGHTING FUNCTIONS
-- ============================================================================

--- Sets a light to a specific mode with smooth transitions
--
-- This is the main function for controlling lights. It:
--   1. Looks up the light mode definition
--   2. Finds the light object by GUID (GUID is required for all lights)
--   3. Saves the mode to game state
--   4. Smoothly transitions all properties using U.Lerp
--
-- Supports per-player lights (if isPlayerLight=true in mode definition).
-- Modes can be static tables or dynamic functions that calculate values.
--
-- All lights must have a GUID defined in their light mode definition.
--
-- @param lightName string The name of the light (must exist in L.LIGHTMODES)
-- @param mode string The mode name to apply (e.g., "OFF", "STANDARD", "ambient", "bright")
-- @param player Player|string|nil Optional: Player for player-specific lights
-- @param transitionTime number Optional: Transition duration in seconds (default: 0.5)
-- @return function|nil Returns completion function if using coroutines, or nil
--
-- @usage L.SetLightMode("playerLightBrown", "STANDARD", "Brown", 0.5) -- Player-specific light by GUID
-- @usage L.SetLightMode("playerLightBrown", "OFF", nil, 1.0) -- Turn off player light (player optional for GUID-based lights)
function L.SetLightMode(lightName, mode, player, transitionTime)
    if transitionTime == nil then
        transitionTime = DefaultTransitionTime
    end

    -- Support array of light names (batch operation)
    if U.Type(lightName) == "table" then
        return U.map(lightName, function(lName)
            return L.SetLightMode(lName, mode, player, transitionTime)
        end)
    end

    -- Validate light mode exists
    U.Val("SetLightMode", lightName,
        U.Type(lightName) == "string" and L.LIGHTMODES[lightName] ~= nil,
        "Mode Data Not Found for light: " .. U.ToString(lightName))

    local lData = L.LIGHTMODES[lightName]
    local isSpawned = lData.isSpawned or false

    -- Handle player-specific lights (for state saving only)
    -- All lights with GUIDs use GUID-based lookup (simplified logic)
    -- Player parameter is optional and only used for state saving
    if lData.isPlayerLight then
        -- Resolve player object if provided (only needed for state saving)
        -- Player can be nil - that's fine for GUID-based lights
        if player then
            local playerObj = nil
            if U.isPlayer(player) then
                playerObj = player
            elseif type(player) == "string" then
                -- Try to get player object by color (may be nil if not seated)
                playerObj = Player[player]
            end
            player = playerObj  -- Can be nil, that's okay for GUID-based lights
        end
    else
        -- Non-player lights shouldn't have player parameter
        U.Val("SetLightMode", {lightName, player}, player == nil,
            "Player submitted to non-player light", {isThrowing = false})
        player = nil
    end

    -- Find the light object
    local light = getLight(lightName, true)
    if light == nil and isSpawned then
        -- Wait for light to spawn if it's a spawned light
        return U.waitUntil(function()
            return L.SetLightMode(lightName, mode, player, transitionTime)
        end, function()
            return getLight(lightName, true) ~= nil
        end, false)
    end

    U.Val("SetLightMode", {lightName, player},
        U.isGameObject(light), "No light found: " .. U.ToString(lightName))

    -- Save mode to state
    -- For player lights, save per-player if player object is available
    -- For GUID-based lights, player may be nil (that's okay)
    if player and U.isPlayer(player) and player.color then
        local sData = S.getStateVal("lights", lightName) or {}
        sData[player.color] = mode
        S.setStateVal(sData, "lights", lightName)
    else
        -- Save mode without player-specific data (works for both non-player lights and GUID-based player lights without player object)
        S.setStateVal(mode, "lights", lightName)
    end

    -- Resolve mode (could be function, string default, or table)
    local modeData = mode
    if U.Type(modeData) == "function" then
        modeData = modeData(player)
    elseif U.Type(modeData) == "string" and modeData == "default" then
        modeData = lData.default or "off"
    end

    -- Get mode definition
    U.Val("SetLightMode", modeData,
        U.Type(modeData) == "string" and lData[modeData] ~= nil,
        "No such mode '" .. U.ToString(modeData) .. "' for light '" .. U.ToString(lightName) .. "'")

    local modeDef = lData[modeData]
    if U.Type(modeDef) == "function" then
        modeDef = modeDef(player) -- Dynamic mode calculation
    end
    if U.Type(modeDef) == "table" then
        modeDef = U.clone(modeDef) -- Clone to avoid modifying original
    end

    -- Apply the light mode with smooth transitions
    local function activateLight()
        local afterVals = {}

        -- Handle enabled state (special case: animate on/off)
        if modeDef.enabled ~= nil then
            if modeDef.enabled == getEnabled(light) then
                modeDef.enabled = nil -- Skip if already in correct state
            elseif modeDef.enabled == true then
                -- Turn on: set intensity to 0 first, then fade in
                setIntensity(light, 0)
                setAngle(light, 0)
                setEnabled(light, true)
            else
                -- Turn off: fade out, then disable
                afterVals.intensity = getIntensity(light)
                afterVals.angle = getAngle(light)
                modeDef.intensity = 0
                modeDef.angle = 0
            end
        end

        -- Create lerp functions for each property that needs transitioning
        return U.RunSequence({
            function()
                local lerpFuncs = {}

                if modeDef.range ~= nil then
                    table.insert(lerpFuncs, U.Lerp(function(range)
                        setRange(light, range)
                    end, getRange(light), modeDef.range, transitionTime))
                end

                if modeDef.intensity ~= nil then
                    table.insert(lerpFuncs, U.Lerp(function(intensity)
                        setIntensity(light, intensity)
                    end, getIntensity(light), modeDef.intensity, transitionTime))
                end

                if modeDef.angle ~= nil then
                    table.insert(lerpFuncs, U.Lerp(function(angle)
                        setAngle(light, angle)
                    end, getAngle(light), modeDef.angle, transitionTime))
                end

                if modeDef.color ~= nil then
                    table.insert(lerpFuncs, U.Lerp(function(color)
                        setColor(light, color)
                    end, getColor(light), Color(modeDef.color), transitionTime))
                end

                if modeDef.rotation ~= nil then
                    table.insert(lerpFuncs, U.setRotationSlow(light, Vector(modeDef.rotation), transitionTime))
                end

                if modeDef.position ~= nil then
                    table.insert(lerpFuncs, U.setPositionSlow(light, Vector(modeDef.position), transitionTime))
                end

                return lerpFuncs
            end,
            function()
                -- Finalize enabled state if turning off
                if modeDef.enabled == false then
                    setEnabled(light, false)
                    setIntensity(light, afterVals.intensity)
                    setAngle(light, afterVals.angle)
                end
            end
        })
    end

    -- Wait for light component if needed
    if isSpawned and getLightComponent(light, true) == nil then
        return U.waitUntil(activateLight, function()
            return getLightComponent(light, true) ~= nil
        end, false)
    end

    return activateLight()
end

--- Loads saved light states from game state
-- Called during initialization to restore lights to their saved states.
-- @usage L.InitLights() -- Called in core/main.ttslua onLoad
function L.InitLights()
    local savedLights = S.getStateVal("lights") or {}

    U.forEach(savedLights, function(mData, lightName)
        if U.Type(mData) == "string" then
            -- Simple mode (single string)
            L.SetLightMode(lightName, mData, nil, 0.5)
        elseif U.Type(mData) == "table" then
            -- Per-player modes (table of color->mode)
            U.forEach(mData, function(mode, pColor)
                L.SetLightMode(lightName, mode, pColor, 0.5)
            end)
        end
    end)
end

--- Resets all lights to their default/off states
-- Useful for cleanup or game reset.
-- @usage L.ResetLights() -- Cleanup after game ends
function L.ResetLights()
    U.forEach(L.LIGHTMODES, function(modes, name)
        if modes.loadRotation then
            local light = getLight(name)
            if light then
                local comp = getLightComponent(light)
                if comp then
                    comp.set("enabled", false)
                    light.setRotation(Vector(180, 0, 0))
                end
            end
        end
    end)
end

--- Applies a mode to multiple lights at once
-- Convenience function for batch operations.
-- @param lightNames string|table Light name(s) to affect (string or array)
-- @param lightMode string Mode to apply (default: "default")
-- @param transitionTime number Transition duration (default: 3.0)
-- @param playerRef Player|string|nil Optional: Player for player-specific lights
-- @return number The transition time (for chaining)
-- @usage L.LoadLights({"playerLightBrown", "playerLightOrange"}, "STANDARD", 2.0)
function L.LoadLights(lightNames, lightMode, transitionTime, playerRef)
    if U.Type(lightNames) == "string" then
        lightNames = {lightNames}
    end
    if lightMode == nil then
        lightMode = "default"
    end
    if transitionTime == nil then
        transitionTime = 3.0
    end

    -- Filter to only lights that exist in LIGHTMODES
    local validLights = U.filter(L.LIGHTMODES, function(_, name)
        return U.isIn(name, lightNames)
    end)

    U.forEach(validLights, function(modes, name)
        if modes[lightMode] == nil then
            U.AlertGM("No Such Mode: " .. U.ToString(lightMode) .. " for light '" .. U.ToString(name) .. "'")
            return
        end

        if lightMode == "default" and U.Type(modes.default) == "string" then
            L.SetLightMode(name, modes.default, playerRef, transitionTime)
        else
            L.SetLightMode(name, lightMode, playerRef, transitionTime)
        end
    end)

    return transitionTime
end

-- ============================================================================
-- PUBLIC API EXPORTS
-- ============================================================================

--- Gets a light object by name (requires GUID in light mode definition)
-- @param lightName string The light name
-- @return Object|nil The light object
-- @usage local light = L.GetLight("playerLightBrown")
L.GetLight = getLight

-- Low-level property setters (for direct control without modes)
L.SetIntensity = setIntensity
L.SetAngle = setAngle
L.SetColor = setColor
L.SetRange = setRange

return L
