# System Instructions for Toronto Rising TTS Project

## Project Context

This is a **Vampire: The Masquerade 5th Edition (VTM5E) Tabletop Simulator module** written in Lua. The codebase is organized into modular libraries and core game logic, following patterns extracted from Heritage and Kings Dilemma reference modules.

**Key Technologies:**
- Lua 5.1 (TTS scripting environment)
- Tabletop Simulator API
- Module-based architecture with `require()` system
- TTS Tools extension for bundling

## Critical Workflow Rules

### Git Commits - MANDATORY

**You MUST commit changes regularly without waiting for user prompts.** This is a core requirement.

- Commit after completing logical units of work (features, fixes, refactoring)
- Commit when documentation is updated
- Commit when multiple related changes are made together
- **Do NOT wait for explicit user requests to commit**

**Commit Message Format:**
- Use present tense ("Add feature" not "Added feature")
- Start with a verb describing the action
- Include a brief summary line, then detailed bullet points
- Reference related Linear issues when applicable (e.g., "TOR-123")

**Example:**
```
Implement GUID-based player lighting system

- Refactored lighting module to use GUID-based lookup for player lights
- Player lights no longer require player data for control
- Updated test functions to use new GUID library
- Related: TOR-9, TOR-10
```

### Linear Issue Tracking - MANDATORY

**Linear is the source of truth for project state and task tracking.** You MUST keep Linear issues synchronized with code changes and development plans.

#### When to Check Linear

- **Before starting work**: Check Linear for current project state and assigned tasks
- **When planning changes**: Review related Linear issues to understand requirements
- **After completing work**: Update Linear issues to reflect completion and changes

#### When to Update Linear Issues

**You MUST update Linear issues in these situations:**

1. **Completing Work**
   - Mark issues as "Done" when features/fixes are complete
   - Add comments summarizing what was implemented
   - Include relevant commit hashes or PR references

2. **Changing Development Plans**
   - Update issue descriptions if requirements change
   - Add comments explaining why plans changed
   - Update status if work is blocked or deferred
   - Create new issues if new tasks are identified

3. **Making Architectural Changes**
   - Update related issues if architecture decisions affect planned work
   - Add comments documenting architectural decisions
   - Link related issues if changes impact multiple areas

4. **Discovering Issues or Blockers**
   - Create new Linear issues for bugs or blockers discovered during work
   - Update existing issues if blockers are found
   - Add comments with details about the issue

5. **Documentation Updates**
   - Update issues if documentation changes affect planned features
   - Add comments when documentation is updated for clarity

#### Linear Issue Update Requirements

**Always include in Linear updates:**
- Clear description of what changed
- Why the change was made (if not obvious)
- Impact on other issues or features
- Relevant code references (files, functions, commits)

**Example Linear Comment:**
```
Completed GUID library separation (commit: 4c4f362)

- Created lib/guids.ttslua with G library for all GUID references
- Moved all GUID code from constants to guids library
- Updated all code references (lighting, debug, main modules)
- Updated documentation to reflect new structure

This change improves code organization by separating GUID management
from game constants. All GUID access now uses G library instead of C.

Related issues: TOR-9 (completed), TOR-10 (completed)
```

#### Linear Issue Status Management

- **In Progress**: Update when actively working on an issue
- **Done**: Mark when work is complete and committed
- **Blocked**: Update if work cannot proceed (with explanation)
- **Canceled**: Update if work is no longer needed (with reason)

#### Consistency Requirements

**Linear issues MUST always be consistent with:**
- Current codebase state (if issue says "done", code should reflect that)
- Development plans (if plans change, issues must be updated)
- Documentation (documentation should match issue descriptions)
- Commit messages (commits should reference related Linear issues)

**If you notice inconsistencies:**
- Update Linear issues immediately to match reality
- Add comments explaining any discrepancies
- Ensure all related issues are synchronized

#### Finding and Using Linear Issues

- Check Linear for issues related to your current work
- Reference Linear issue IDs (e.g., "TOR-123") in commit messages
- Use Linear to understand project priorities and next tasks
- Review Linear before making significant changes to understand context

## Code Organization

### Directory Structure

- `lib/` - Shared libraries and utilities (constants, guids, util)
- `core/` - Core game logic modules (state, lighting, main, scenes, zones, debug)
- `dev/` - Development tools, documentation, and reference materials
- `ui/` - UI XML files and related resources
- `.tts/` - TTS Tools extension output directory (auto-generated)

### File Naming Conventions

- Use `.ttslua` extension for Lua module files
- Use `.md` for documentation files
- Use `.xml` for UI definitions
- Use `.lua` only for entry point files (e.g., `.tts/objects/Global.lua`)

### Module Structure Pattern

All modules follow this pattern:

```lua
-- lib/module_name.ttslua
-- Module Description
-- Brief explanation of purpose

local ModuleName = {}
local Dependency1 = require("lib.dependency1")
local Dependency2 = require("core.dependency2")

-- Module code here

return ModuleName
```

## Code Style and Conventions

### Naming Conventions

- **Modules**: PascalCase for module names (`local C = require("lib.constants")`)
- **Functions**: camelCase for function names (`function M.setupPlayers()`)
- **Constants**: UPPER_SNAKE_CASE for constants (`C.MAX_HUNGER`)
- **Variables**: camelCase for variables (`local playerColor`)
- **Tables**: PascalCase for table names (`C.PlayerColors`)

### Indentation and Formatting

- Use **spaces, not tabs** (typically 4 spaces per indent level)
- Maintain consistent indentation throughout files
- Use double quotes for strings
- Use string templates or `.join()` instead of direct concatenation

### Comments and Documentation

- Include JSDoc-style function headers with:
  - `@param` for parameters
  - `@return` for return values
  - `@usage` for usage examples
- Add inline comments for complex logic
- Document module purpose at the top of each file

### Error Handling

- Use `pcall` for safe execution where appropriate
- Use `U.Val()` for assertions and validation (from util library)
- Provide clear, descriptive error messages
- Validate inputs before processing
- Return `nil` on error when appropriate, with clear error messages

### Type Safety

- Use strict type checking with `U.Type()` from util library
- Validate function parameters before use
- Use `U.isPlayer()`, `U.isGameObject()`, etc. for type validation
- **Do NOT use `any` type** (this is Lua, but avoid loose typing)
- **Do NOT use non-null assertion operator (`!`)**
- **Do NOT cast to unknown** (e.g., `as unknown as T`)

## Module Dependencies

### Core Module Dependencies

**Always require in this order:**
1. `lib/constants` (C) - Game constants and configuration
2. `lib/guids` (G) - GUID references for TTS objects
3. `lib/util` (U) - Utility functions library
4. `core/state` (S) - State management
5. Other core modules as needed

**Example:**
```lua
local M = {}
local U = require("lib.util")
local C = require("lib.constants")
local G = require("lib.guids")
local S = require("core.state")
```

### Module Loading Order

Modules must be loaded in dependency order:
1. Constants and utilities (`lib/`)
2. Core modules (`core/`)
3. Main game logic
4. Debug/testing modules (development only)

## Common Patterns and Best Practices

### Before Writing New Code

**ALWAYS check these first:**
1. `dev/AVAILABLE_FUNCTIONS.md` - Comprehensive function reference
2. `lib/util.ttslua` - 75+ utility functions (map, filter, find, etc.)
3. Existing modules for similar patterns
4. **Only create new functions if no existing function meets your needs**

**Common mistakes to avoid:**
- ❌ Writing custom `map`/`filter` when `U.map()`/`U.filter()` exist
- ❌ Writing custom type checking when `U.Type()` exists
- ❌ Writing custom state access when `S.getStateVal()`/`S.setStateVal()` exist
- ❌ Duplicating functionality that already exists

### State Management Pattern

**Always use state module functions:**
```lua
-- ✅ CORRECT
local hunger = S.getStateVal("players", playerColor, "hunger")
S.setStateVal("players", playerColor, "hunger", 3)

-- ❌ WRONG
local hunger = S.state.players[playerColor].hunger  -- Direct access
```

### Player Iteration Pattern

**Use the standard pattern:**
```lua
function M.forPlayers(callback)
    for _, color in ipairs(C.PlayerColors) do
        local player = Player[color]
        if player then
            callback(player, color)
        end
    end
end
```

### GUID Access Pattern

**Always use G library for GUIDs:**
```lua
-- ✅ CORRECT
local guid = G.GetHandZoneGUID(color)
local guid = G.GUIDS.PLAYER_LIGHT_BROWN

-- ❌ WRONG
local guid = C.GUIDS.PLAYER_LIGHT_BROWN  -- GUIDs moved to G library
```

### Error Validation Pattern

**Use U.Val() for assertions:**
```lua
U.Val("functionName", {param1 = value1}, condition, "Error message if false")
```

### Coroutine Pattern

**For async operations:**
```lua
-- Functions using U.waitUntil, U.RunSequence, U.Lerp require:
startLuaCoroutine(Global, "CoroutineName")

-- In Global context, 'self' refers to Global
```

## Testing Requirements

### Test Functions

- All test functions are in `core/debug.ttslua`
- Test functions are exposed globally and callable from TTS console
- Update test functions when adding new features
- Document test requirements in `dev/TESTING.md`

### Testing Before Committing

- Verify changes work in TTS when possible
- Run relevant test functions
- Check console for errors
- Verify UI updates correctly

## Documentation Standards

### When to Update Documentation

- **Always** update documentation when making changes
- Add examples for new functions
- Document breaking changes
- Keep README files current
- Update `dev/AVAILABLE_FUNCTIONS.md` when adding new functions

### Key Documentation Files

- `dev/TESTING.md` - Testing guide and test functions
- `dev/GUID_REQUIREMENTS.md` - GUID requirements and setup
- `dev/AVAILABLE_FUNCTIONS.md` - Function reference (check before coding)
- `dev/DEVELOPMENT_WORKFLOW.md` - Development workflow and best practices
- `dev/EXTRACTABLE_FUNCTIONS_INDEX.md` - Reference patterns from other modules

## Player Colors and IDs

### Player Color System

- **Storyteller**: Always "Black"
- **Players**: "Brown", "Orange", "Red", "Pink" (in that order)
- **Important**: All state-based player data must be stored by **player ID**, not color or name
- Player IDs are stored in `C.PlayerIDs` and must be manually updated

### Color Usage

- Use `C.PlayerColors` array for iteration
- Use `C.STORYTELLER_COLOR` constant for Storyteller color
- Validate colors before use

## Common Issues and Solutions

### Module Not Found
- Check require paths match file locations
- Verify file extensions (`.ttslua` not `.lua` for modules)
- Check module is in correct directory

### GUID Errors
- Verify GUIDs in `lib/guids.ttslua` match actual TTS objects
- Use `G.GetHandZoneGUID()`, `G.GetSignalFireGUID()`, etc. helper functions
- Check console for "object not found" errors

### State Persistence
- Always use `S.getStateVal()` and `S.setStateVal()` for state access
- Ensure state is saved before game reload
- Check state structure matches expected format

### UI Not Updating
- Check UI element IDs match between XML and update functions
- Verify player colors match (case-sensitive: "Red" not "red")
- Ensure `updateUIDisplays()` is called after state changes

## TTS-Specific Considerations

### TTS API Context

- `Global` context for global scripts
- `self` refers to Global in global context
- Object scripts have `self` referring to the object
- Use `getObjectFromGUID()` for object lookup
- Use `getObjectsWithAllTags()` for tag-based queries

### Bundling System

- TTS Tools extension bundles code automatically
- Entry point: `.tts/objects/Global.lua`
- Module files in workspace directory are bundled via `require()`
- Use "Save and Play" to bundle and send to TTS

### Coroutines

- Coroutine functions require `startLuaCoroutine(Global, "FunctionName")`
- Use `U.waitUntil()`, `U.RunSequence()`, `U.Lerp()` for async operations
- Coroutines run in Global context

## Code Completion Requirements

### Always Include

- Full code implementation (no placeholders)
- Error checking and type validation
- Clear inline comments and JSDoc headers
- Appropriate error messages
- Documentation updates when needed

### Never Include

- Placeholder code without implementation
- `any` type usage
- Non-null assertion operators (`!`)
- Unknown type casts
- Direct string concatenation (use templates or `.join()`)

## Questions to Ask Before Coding

1. Does this functionality already exist? (Check `dev/AVAILABLE_FUNCTIONS.md`)
2. Is there a utility function I should use? (Check `lib/util.ttslua`)
3. Am I following existing patterns? (Check similar code in codebase)
4. Have I checked Linear for related issues and current project state?
5. Have I updated documentation? (Update relevant docs)
6. Have I updated Linear issues to reflect any changes?
7. Should I commit this? (Yes - commit after logical units of work)

---

**Last Updated**: After GUID library separation
**Reference**: See `dev/DEVELOPMENT_WORKFLOW.md` for detailed workflow information
