--[[
    Shared Dice Roller Code - Complete Implementation
    This file contains ALL dice roller functionality.
    Instance scripts only need to require this and set isHunger flag.

    The TTS Lua extension will automatically bundle this file when you use require().
    Enable "TTSLua: Include Other Files" in settings for this to work.
--]]

--[[
    Initialize the dice roller
    @param rollerSelf - The self object (passed from instance script)
    @param config - Configuration table: {isHunger = true/false, customSettings = {...}}
--]]
function initDiceRoller(rollerSelf, config)
    -- Store self reference (will be used in closures)
    local rollerSelfRef = rollerSelf
    local isHunger = config.isHunger or false

    -- Default settings
    setting = {print={}}
    setting.setup = false
    setting.radius = 4
    setting.arc = 180
    setting.rotation = 180
    setting.height = 1.5
    setting.scale = 1.7
    setting.maxCount = 15
    setting.rollDelay = 1.2
    setting.cleanupDelay = -1
    setting.colorDie = false
    setting.print.player = false
    setting.print.individual = false
    setting.print.total = false
    setting.print.playerColor = true
    setting.coop = false

    -- Override with custom settings if provided
    if config.customSettings then
        for k, v in pairs(config.customSettings) do
            if type(v) == "table" and setting[k] and type(setting[k]) == "table" then
                for k2, v2 in pairs(v) do
                    setting[k][k2] = v2
                end
            else
                setting[k] = v
            end
        end
    end

    -- Initialize dice tracking
    spawnedDice = {}

    -- Save function (triggered when adding a die or clearing the dice)
    onSave = function()
        local tableToSave = {}
        for _, die in ipairs(spawnedDice) do
            if die ~= nil then
                table.insert(tableToSave, die.getGUID())
            end
        end
        saved_data = JSON.encode(tableToSave)
        return saved_data
    end

    onLoad = function(saved_data)
        if saved_data ~= "" then
            --Remove any old dice from the table
            local loaded_data = JSON.decode(saved_data)
            for _, dieGUID in ipairs(loaded_data) do
                local die = getObjectFromGUID(dieGUID)
                if die ~= nil then
                    destroyObject(die)
                end
            end
            spawnedDice = {}
        else
            spawnedDice = {}
        end

        math.randomseed(os.time())
        createButtons()
    end

    -- Spawn dice for rolling
    click_roll = function(_, color)
        --Dice spam protection check
        local denyRoll = false
        if setting.maxCount > 0 and #spawnedDice >= setting.maxCount then
            denyRoll = true
        end
        if rollInProgress==nil and denyRoll==false and anyRollInProgress(color)==false then
            --Find dice positions, moving previously spawned dice if needed
            for i, die in ipairs(spawnedDice) do
                local pos_local = getLocalPointOnArc(i, #spawnedDice+1)
                local pos = rollerSelfRef.positionToWorld(pos_local)
                die.setPositionSmooth(pos)
            end

            --Spawns dice
            local pos_local = getLocalPointOnArc(#spawnedDice+1, #spawnedDice+1)
            local spawnedDie = rollerSelfRef.takeObject({
                position = rollerSelfRef.positionToWorld(pos_local),
                rotation = randomRotation(),
            })

            --Setup die that was just spawned
            spawnedDie.setScale({setting.scale,setting.scale,setting.scale})
            spawnedDie.setLock(true)
            if setting.colorDie == true then
                spawnedDie.setColorTint(stringColorToRGB(color))
            end
            --Mark as hunger or normal die
            spawnedDie.script_state = isHunger and "hunger" or "normal"

            rollTimerUpdate({color=color})

            --Update data
            table.insert(spawnedDice, spawnedDie)
            updateGlobalTable(color)
            updateRollTimers(color)

        elseif rollInProgress == false then
            --If after roll but before cleanup
            cleanupDice()
            click_roll(_, color)
        else
            --If button click is denied due to roll (or 2 many dice)
            Player[color].broadcast("Roll in progress.", {0.8, 0.2, 0.2})
        end
    end

    rollTimerUpdate = function(param)
        --Timer starting
        Timer.destroy("clickRoller_"..rollerSelfRef.getGUID())
        Timer.create({
            identifier="clickRoller_"..rollerSelfRef.getGUID(), delay=setting.rollDelay,
            function_name="timer_rollDice", function_owner=rollerSelfRef,
            parameters = param
        })
    end

    --Rolls all the dice and then launches monitoring
    timer_rollDice = function(p)
        rollInProgress = true
        function coroutine_rollDice()
            for _, die in ipairs(spawnedDice) do
                die.setLock(false)
                die.randomize()
                wait(0.1)
            end

            monitorDice(p.color)

            return 1
        end
        startLuaCoroutine(rollerSelfRef, "coroutine_rollDice")
    end

    --Monitors dice to come to rest
    monitorDice = function(color)
        function coroutine_monitorDice()
            repeat
                local allRest = true
                for _, die in ipairs(spawnedDice) do
                    if die ~= nil and die.resting == false then
                        allRest = false
                    end
                end
                coroutine.yield(0)
            until allRest == true

            if areOtherRollersRolling(color)==true and setting.coop==true then
                --If other coop rollers are rolling
                rollingHasStopped = true
                return 1
            else
                --If roll is complete and no further waiting is required
                if setting.print.individual==true or setting.print.total==true then
                    displayResults(color)
                end
                finalizeRoll({color=color})
                if setting.coop == true then finalizeCoopRolls(color) end
            end

            return 1
        end
        startLuaCoroutine(self, "coroutine_monitorDice")
    end

    finalizeRoll = function(p)
        local color = p.color
        rollingHasStopped = nil --Used for coop communication
        rollInProgress = false --Used for button lockout
        updateGlobalTable(nil)

        --Auto die removal
        if setting.cleanupDelay > -1 then
            --Timer starting
            Timer.destroy("clickRoller_cleanup_"..rollerSelfRef.getGUID())
            Timer.create({
                identifier="clickRoller_cleanup_"..rollerSelfRef.getGUID(),
                function_name="cleanupDice", function_owner=rollerSelfRef,
                delay=setting.cleanupDelay,
            })
        end
    end

    --Removes the dice
    cleanupDice = function()
        for _, die in ipairs(spawnedDice) do
            if die ~= nil then
                destroyObject(die)
            end
        end

        rollInProgress = nil
        spawnedDice = {}

        Timer.destroy("clickRoller_cleanup_"..rollerSelfRef.getGUID())
    end

    displayResults = function(color)
        --Combine dice from coop rollers if enabled
        addAllSpawnedDice(color)

        --Use Global script for V5 calculations
        local s = ""

        --Player name
        if setting.print.player == true then
            s = Player[color].steam_name
            if setting.print.individual==true or setting.print.total==true then
                s = s .. "    " .. string.char(9679) .. "    "
            end
        end

        --Collect dice data with hunger tracking
        local diceData = {}
        for _, die in ipairs(spawnedDice) do
            if die ~= nil then
                local value = tonumber(die.getRotationValue())
                local isHungerDie = (die.script_state == "hunger")
                table.insert(diceData, {value=value, isHunger=isHungerDie})
            end
        end

        --Individual values display
        if setting.print.individual == true then
            local formatted = Global.call("formatDiceValues", diceData)
            s = s .. formatted
            if setting.print.total == true then
                s = s .. "    " .. string.char(9679) .. "    "
            end
        end

        --Calculate results using Global script
        if setting.print.total == true then
            local results = Global.call("calculateV5DiceResults", diceData)
            s = s .. results.message
        end

        --Establish color
        local stringColor = {1,1,1}
        if setting.print.playerColor == true then
            stringColor = stringColorToRGB(color)
        end
        --Broadcast result
        printToAll(' ', stringColor)
        broadcastToAll(s, stringColor)
    end

    --Updates global rolling table with its information
    updateGlobalTable = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable == nil then
                Global.setTable("UCR_communication", {[rollerSelfRef]=color})
            else
                currentTable[rollerSelfRef] = color
                Global.setTable("UCR_communication", currentTable)
            end
        end
    end

    --Updates roll timers for all devices currently rolling
    updateRollTimers = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable != nil then
                for who, c in pairs(currentTable) do
                    if who~=rollerSelfRef and c==color then
                        who.call("rollTimerUpdate", {color=color})
                    end
                end
            end
        end
    end

    --Check if any other roller is rolling
    areOtherRollersRolling = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable == nil then
                return false
            else
                for who, c in pairs(currentTable) do
                    if who~=rollerSelfRef and c==color then
                        if who.getVar("rollingHasStopped") ~= true then
                            return true
                        end
                    end
                end
            end
            return false
        else
            return false
        end
    end

    --Check if any other roller is rolling
    anyRollInProgress = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable == nil then
                return false
            else
                for who, c in pairs(currentTable) do
                    if who~=rollerSelfRef and c==color then
                        if who.getVar("rollInProgress") ~= nil then
                            return true
                        end
                    end
                end
            end
            return false
        else
            return false
        end
    end

    --Activate the finalize step on all dice of this color
    finalizeCoopRolls = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable != nil then
                for who, c in pairs(currentTable) do
                    if c==color then
                        who.call("finalizeRoll", {color=color})
                    end
                end
            end
        end
    end

    --Combines all spawnedDice tables from all coop rollers
    addAllSpawnedDice = function(color)
        if setting.coop==true then
            local currentTable = Global.getTable("UCR_communication")
            if currentTable != nil then
                for who, c in pairs(currentTable) do
                    if who~=rollerSelfRef and c==color then
                        theirSpawnedDice = who.getTable("spawnedDice")
                        if theirSpawnedDice ~= nil then
                            for _, die in ipairs(theirSpawnedDice) do
                                table.insert(spawnedDice, die)
                            end
                        end
                    end
                end
            end
        end
    end

    --Finds a local point an an arc, given which point and the total # of points
    getLocalPointOnArc = function(i, points)
        i = i - 0.5
        local angle = setting.arc/(points)
        local offset = -setting.arc/2 + setting.rotation
        local x = math.sin( math.rad(angle*i+offset) ) * setting.radius
        local y = setting.height
        local z = math.cos( math.rad(angle*i+offset) ) * setting.radius
        return {x=x,y=y,z=z}
    end

    --Gets a random rotation vector
    randomRotation = function()
        --Credit for this function goes to Revinor (forums)
        local u1 = math.random();
        local u2 = math.random();
        local u3 = math.random();
        local u1sqrt = math.sqrt(u1);
        local u1m1sqrt = math.sqrt(1-u1);
        local qx = u1m1sqrt *math.sin(2*math.pi*u2);
        local qy = u1m1sqrt *math.cos(2*math.pi*u2);
        local qz = u1sqrt *math.sin(2*math.pi*u3);
        local qw = u1sqrt *math.cos(2*math.pi*u3);
        local ysqr = qy * qy;
        local t0 = -2.0 * (ysqr + qz * qz) + 1.0;
        local t1 = 2.0 * (qx * qy - qw * qz);
        local t2 = -2.0 * (qx * qz + qw * qy);
        local t3 = 2.0 * (qy * qz - qw * qx);
        local t4 = -2.0 * (qx * qx + ysqr) + 1.0;
        if t2 > 1.0 then t2 = 1.0 end
        if t2 < -1.0 then ts = -1.0 end
        local xr = math.asin(t2);
        local yr = math.atan2(t3, t4);
        local zr = math.atan2(t1, t0);
        return {math.deg(xr),math.deg(yr),math.deg(zr)}
    end

    --Coroutine delay, in seconds
    wait = function(time)
        local start = os.time()
        repeat coroutine.yield(0) until os.time() > start + time
    end

    --Spawns the roll button or the "display roll locations" for setup mode
    createButtons = function()
        if setting.setup ~= true then
            rollerSelfRef.createButton({
                click_function="click_roll", function_owner=rollerSelfRef,
                position={0,0.05,0}, height=650, width=650, color={1,1,1,0}
            })
        else
            for i=1, math.ceil(setting.arc/30) do
                local pos_local = getLocalPointOnArc(i, math.ceil(setting.arc/30))
                rollerSelfRef.createButton({
                    click_function="none", function_owner=rollerSelfRef,
                    position=pos_local, height=0, width=0, label=string.char(9673),
                    font_size=1000, font_color={0.5,0.5,0.5}
                })
            end
        end
    end
end

return {
    initDiceRoller = initDiceRoller
}
